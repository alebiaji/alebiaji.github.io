<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C/C++基础整理</title>
    <url>/2021/06/29/C++%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="c语言学习整理"><a class="markdownIt-Anchor" href="#c语言学习整理"></a> C语言学习整理</h1>
<ol>
<li><strong>Linux进程地址空间图</strong></li>
</ol>
<img src="/images/进程地址空间.png" alt="img 进程地址空间" style="zoom: 80%;">
<span id="more"></span>
<ol start="2">
<li><strong>编译过程</strong></li>
</ol>
<img src="/images/编译过程.png" alt="img 进程地址空间" style="zoom: 80%;">
<ol start="3">
<li>
<p>变量是有名字的内存空间，其内存空间由数据类型决定大小和解释方式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1B = 8bit</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">int</span>) = <span class="number">4B</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">char</span>) = <span class="number">1B</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">long</span>) = <span class="number">4B</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">short</span>) = <span class="number">2B</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">float</span>) = <span class="number">4B</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">double</span>) = <span class="number">8B</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">void</span> *) = <span class="number">8B</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) = <span class="number">8B</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不同进制数的输出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//十进制输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;123 = %d\n&quot;</span>, <span class="number">123</span>);	</span><br><span class="line">    <span class="comment">//八进制输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0123 = %d\n&quot;</span>, <span class="number">0123</span>);	</span><br><span class="line">    <span class="comment">//十六进制输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x123 = %d\n&quot;</span>, <span class="number">0x123</span>);	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">123 = 123</span></span><br><span class="line"><span class="comment">0123 = 83</span></span><br><span class="line"><span class="comment">0x123 = 291</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>x进制 -&gt; 10进制：<br>
<img src="/images/x进制转10进制.png" alt="img x进制转10进制"><br>
2进制 -&gt; 8进制：每三位为一组</p>
<p>2进制 -&gt; 16进制：每四位为一组</p>
<p><strong>10进制 -&gt; 2进制</strong>：<a href="https://baike.baidu.com/item/%E9%99%A4k%E5%8F%96%E4%BD%99%E6%B3%95/19385576?fr=aladdin">除2取余法</a></p>
</li>
<li>
<p>内存中一般用<strong>小端存储</strong><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>法存储数据，int占据4个字节，a的地址是addr_a，b的地址是addr_b，根据以下代码说明变量a和b的真值、机器数和内存布局（每个字节的内容）分别如何？还有一种<strong>大端存储</strong><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ... //</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">-1234</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2345</span>;</span><br><span class="line"><span class="comment">// ... //</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>变量a</th>
<th>变量b</th>
</tr>
</thead>
<tbody>
<tr>
<td>真值</td>
<td>-1234</td>
<td>2345</td>
</tr>
<tr>
<td>机器数</td>
<td>FF FF FB 2E</td>
<td>00 00 09 29</td>
</tr>
<tr>
<td>内存布局</td>
<td>2E FB FF FF</td>
<td>29 09 00 00</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a href="https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613?fr=aladdin">补码</a>：有符号整型在计算机中采取补码的编码方式，通过给一个数补上一个周期，把减法变成加法。</p>
<ul>
<li>
<p>正整数：正整数的补码与原码相同。</p>
</li>
<li>
<p>负整数：负整数的补码是将其除<strong>符号位</strong><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>以外，其余所有位取反后加1。</p>
</li>
<li>
<p>0：0的补码是唯一表示的。</p>
</li>
</ul>
</li>
<li>
<p>根据机器数的大小比较真值的大小</p>
<ol>
<li>符号不同，正数 &gt; 负数</li>
<li>符号相同，机器数越大，真值越大</li>
<li>
<ul>
<li>最大负整数：1,111 1111 … = -1</li>
<li>最小负整数：1,000 0000 … = -2^(n-1)</li>
<li>最大正整数：0,111 1111 … = 2^(n-1) - 1</li>
<li>可表示的范围：-2^(n-1) ~ 2^(n-1) - 1</li>
</ul>
</li>
</ol>
</li>
<li>
<p>机器数相同，真值不一定相同，真值由解释方式决定。</p>
</li>
<li>
<p>两个有符号数的加法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">机器数1 + 机器数2 = 机器数3 -&gt; (用补码方式解释) 真值(可能会溢出)</span><br><span class="line"></span><br><span class="line">例题：给出两个数据-123和12，如果采用原码方式，如何执行加法运算；如果是补码方式，如何执行加法运算？说明在原码加法和补码加法中，分别在哪些步骤中使用了加法器、减法器和大小比较器。</span><br><span class="line"></span><br><span class="line">解：-123和12</span><br><span class="line">原码加法:</span><br><span class="line">	-123 -&gt; 1,111 1011</span><br><span class="line">	12   -&gt; 0,000 1100</span><br><span class="line">	不带符号位参与运算，判断两数绝对值，用绝对值大的减去绝对值小的，符号位与绝对值大的相同。(大小比较器)</span><br><span class="line">	111 1011 - 000 1100 = 110 0111 -&gt; 1,110 1111(减法器)</span><br><span class="line">补码加法:</span><br><span class="line">	-123 -&gt; 1,000 0101</span><br><span class="line">	12   -&gt; 0,000 1100</span><br><span class="line">	负数的补码为符号位不变，原码取反+1，带符号位参与加法运算。负数结果数值位取反+1。</span><br><span class="line">	1,000 0101 + 0,000 1100 = 1,001 0001 -&gt; 1,110 1111(加法器)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>数据的高字节存储在高地址中，数据的低字节存储在低地址中 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>数据的高字节存储在低地址中，数据的低字节存储在高地址中 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>取最高位为符号位 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile</title>
    <url>/2021/07/10/Makefile%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="makefile"><a class="markdownIt-Anchor" href="#makefile"></a> Makefile</h1>
<h4 id="功能通过makefile文件来描述源程序之间的相互关系并自动维护编译工作"><a class="markdownIt-Anchor" href="#功能通过makefile文件来描述源程序之间的相互关系并自动维护编译工作"></a> 功能：通过makefile文件来描述源程序之间的相互关系并自动维护编译工作。</h4>
<span id="more"></span>
<ol>
<li>
<p>Makefile的变量：</p>
<ol>
<li>
<p>自定义变量：<strong>字符串(变量名):=字符串(变量值)</strong>，可通过$(变量名)替代所有的变量值。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#未使用自定义变量</span></span><br><span class="line"><span class="section">main:main.c</span></span><br><span class="line">	gcc main.c -o main</span><br><span class="line">----------------------------</span><br><span class="line"><span class="comment">#使用自定义变量</span></span><br><span class="line">target:=main</span><br><span class="line">src:=main.c</span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(src)</span></span><br><span class="line">	gcc <span class="variable">$(src)</span> -o <span class="variable">$(target)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>自动变量：随规则的变化，同一个变量名对应不同的变量值</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>$@</td>
<td>目标文件</td>
</tr>
<tr>
<td>$&lt;</td>
<td>第一个依赖文件</td>
</tr>
<tr>
<td>$^</td>
<td>所有的依赖文件，以空格分隔</td>
</tr>
<tr>
<td>$?</td>
<td>日期新于目标文件的所有相关文件列表，逗号分隔</td>
</tr>
<tr>
<td>$(@D)</td>
<td>目标文件的目录名部分</td>
</tr>
<tr>
<td>$(@F)</td>
<td>目标文件的文件名部分</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>预定义的变量：有预定义的变量，可以手动其修改含义</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>含义</th>
<th>变量值</th>
</tr>
</thead>
<tbody>
<tr>
<td>AR</td>
<td>打包库文件</td>
<td>ar</td>
</tr>
<tr>
<td>AS</td>
<td>汇编程序</td>
<td>as</td>
</tr>
<tr>
<td>CC</td>
<td>C编译器</td>
<td>cc</td>
</tr>
<tr>
<td>CPP</td>
<td>CPP编译器</td>
<td>$(CC) -E</td>
</tr>
<tr>
<td>CXX</td>
<td>C++编译器</td>
<td>g++</td>
</tr>
<tr>
<td>RM</td>
<td>删除</td>
<td>rm -f</td>
</tr>
</tbody>
</table>
</li>
</ol>
</li>
<li>
<p>wildcard：从文件系统中提取文件名(按照通配符规则)</p>
<p>subst/patsubst：文本替换/按格式文本替换</p>
   <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">srcs:=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span> <span class="comment">#srcs为目录下所有.c文件</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">var:=<span class="string">&quot;How are you&quot;</span></span><br><span class="line">newvar:=<span class="variable">$(<span class="built_in">patsubst</span> you,me,<span class="variable">$(var)</span>)</span> <span class="comment">#将var中所有的you替换成me</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">srcs:=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span> </span><br><span class="line">objs:=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(srcs)</span>)</span> <span class="comment">#将srcs中所有的.c文件替换成.o文件</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>%<strong>匹配字符：从上一个规则的</strong>依赖条件</strong>中按照匹配格式匹配内容，每次匹配成功就生成一个规则，<strong>%<strong>表示匹配得到的内容。(在变量引用时使用</strong>%</strong>)</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">srcs:$(wildcard *.c) </span></span><br><span class="line"><span class="section">objs:$(patsubst %.c,%,<span class="variable">$(srcs)</span>) #匹配srcs中所有的.c文件替换成.o文件</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>for循环：</p>
   <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">srcs:=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">exes:=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%,<span class="variable">$(srcs)</span>)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    for i in <span class="variable">$(exes)</span>; do <span class="variable">$(CC)</span> $$i.c -o $$i; done <span class="comment">#$$i代表$(exes)中的内容</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>伪目标：以不存在的文件作为命令的目标(每次make都会执行)，常用<code>.PHONY</code>来区分伪目标方便阅读。</p>
</li>
<li>
<p>增量编译：</p>
   <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC:=gcc                                                                        </span><br><span class="line">srcs:=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">objs:=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(srcs)</span>)</span></span><br><span class="line">final:=main</span><br><span class="line"><span class="section">all:<span class="variable">$(final)</span></span></span><br><span class="line"><span class="variable">$(final)</span>:<span class="variable">$(objs)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:rebuild clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$(objs)</span> <span class="variable">$(final)</span></span><br><span class="line"><span class="section">rebuild:clean all </span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编译所有.c文件得到可执行文件</p>
   <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC:=gcc                                                                        </span><br><span class="line">srcs:=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">exes:=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%,<span class="variable">$(srcs)</span>)</span></span><br><span class="line"><span class="section">all:<span class="variable">$(exes)</span></span></span><br><span class="line"><span class="section">%:%.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:rebuild clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$(exes)</span></span><br><span class="line"><span class="section">rebuild:clean all</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown</title>
    <url>/2021/06/28/Markdown%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="markdown语法学习"><a class="markdownIt-Anchor" href="#markdown语法学习"></a> Markdown语法学习</h1>
<span id="more"></span>
<p><a href="https://www.runoob.com/markdown/md-link.html">学自菜鸟</a></p>
<ol>
<li>用=和-标记一二级标题</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">我是一级标题</span></span><br><span class="line"><span class="section">=================</span></span><br><span class="line"></span><br><span class="line"><span class="section">我是二级标题</span></span><br><span class="line"><span class="section">-----------------</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>用#标记标题(共6级)</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>换行：<strong>两个空格 + 回车</strong></p>
</li>
<li>
<p>字体加粗or斜体</p>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span></span><br><span class="line"><span class="strong">**粗体**</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体<span class="strong">**<span class="emphasis">*</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong">_斜体_</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong"><span class="strong">__粗体__</span></span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong"><span class="strong">__<span class="emphasis">_粗斜体<span class="strong">__<span class="emphasis">_</span></span></span></span></span></span></span></span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>分割线：可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> <span class="emphasis">* *</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> - -</span><br><span class="line"></span><br><span class="line"><span class="emphasis">_ _</span> <span class="emphasis">_</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li><s>删除线</s>：文字两端加~~</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure>
<ol start="7">
<li><u>下划线</u>：使用HTML中的<code>&lt;u&gt;</code>标签实现</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线<span class="xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ol start="8">
<li><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[^脚注]</span><br></pre></td></tr></table></figure>
<ol start="9">
<li>
<p>无序列表：用(*)(+)(-)后加一个空格表示</p>
</li>
<li>
<p>有序列表：用数字加上.再加一个空格表示</p>
</li>
<li>
<p>Markdown区块：段落开头使用<code>&gt;</code>符号，后面跟一个空格(可以嵌套)</p>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 区块</span></span><br><span class="line"><span class="quote">&gt; &gt; 嵌套</span></span><br></pre></td></tr></table></figure>
<ol start="12">
<li>Markdown链接：</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">链接名</span>](<span class="link">链接地址</span>)</span><br><span class="line">或者</span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure>
<ol start="13">
<li>Markdown图片：</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">name 属性文本</span>](<span class="link">图片地址 &quot;可选标题&quot;</span>)</span><br><span class="line"></span><br><span class="line">可以用<span class="xml"><span class="tag">&lt;<span class="name">img</span>&gt;</span></span>标签指定高度和宽度：<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片地址&quot;</span> <span class="attr">width</span> = <span class="string">&quot;xx%&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ol start="14">
<li>转义：</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">使用\能够正常显示特殊字符，如：</span><br><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line"><span class="bullet">*</span>   星号</span><br><span class="line"><span class="emphasis">_   下划线</span></span><br><span class="line"><span class="emphasis">&#123;&#125;  花括号</span></span><br><span class="line"><span class="emphasis">[]  方括号</span></span><br><span class="line"><span class="emphasis">()  小括号</span></span><br><span class="line"><span class="emphasis">#   井字号</span></span><br><span class="line"><span class="emphasis">+   加号</span></span><br><span class="line"><span class="emphasis">-   减号</span></span><br><span class="line"><span class="emphasis">.   英文句点</span></span><br><span class="line"><span class="emphasis">!   感叹号</span></span><br></pre></td></tr></table></figure>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>要脚注的文字 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Github操作整理</title>
    <url>/2021/08/23/git%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h1 id="github-操作整理"><a class="markdownIt-Anchor" href="#github-操作整理"></a> Github 操作整理</h1>
<p>整理一些github的常用操作</p>
<span id="more"></span>
<h2 id="github上传"><a class="markdownIt-Anchor" href="#github上传"></a> Github上传</h2>
<ol>
<li>初始化：<code>git init</code></li>
<li>添加仓库：<code>git remote add origin https://gitee.com/xxx/project.git</code></li>
<li>切换<code>a</code>分支：<code>git checkout a</code></li>
<li>下载<code>a</code>分支文件：<code>git pull origin a</code></li>
<li>添加用户名：<code>git config --global user.name &quot;e@mail.com&quot;</code></li>
<li>添加邮箱：<code>git config --global user.mail &quot;e@mail.com&quot;</code></li>
<li>添加文件：
<ol>
<li>所有文件：<code>git add .</code></li>
<li>某一文件：<code>git add + 文件名</code></li>
</ol>
</li>
<li>将add的文件commit到仓库：<code>git commit -m &quot;备注&quot;</code></li>
<li>上传文件：<code>git push origin a</code></li>
</ol>
]]></content>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL整理</title>
    <url>/2021/07/15/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h1>
<ol>
<li>
<p>数据库是什么？</p>
<p>数据库是一个实体，是保存和管理数据的“仓库”。</p>
</li>
<li>
<p>为什么要用数据库？</p>
<p>数据库是数据管理的技术和方法，它能更合适的组织数据，更方便的维护数据，更严密的控制数据，更有效的利用数据。</p>
</li>
</ol>
<span id="more"></span>
<h1 id="安装mysql数据库ubuntu-1804-lts"><a class="markdownIt-Anchor" href="#安装mysql数据库ubuntu-1804-lts"></a> 安装MySQL数据库（Ubuntu 18.04 LTS）</h1>
<ol>
<li>
<p>从Ubuntu仓库中安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install mysql-server mysql-client</span><br><span class="line"><span class="comment">#客户端依赖包</span></span><br><span class="line">$ sudo apt-get install libmysqlclient-dev</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>初始化配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo mysql_secure_installation</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>检查MySQL的服务状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl status mysql.service</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">$ sudo service mysql status</span><br></pre></td></tr></table></figure>
<p>Active: <font color="green">active (running)</font> 表示运行成功</p>
</li>
</ol>
<h1 id="mysql常用的数据类型"><a class="markdownIt-Anchor" href="#mysql常用的数据类型"></a> MySQL常用的数据类型</h1>
<img src="/images/MySQL常用数据类型.png" alt="img MySQL常用数据类型">
<h1 id="mysql使用远程登录的配置修改"><a class="markdownIt-Anchor" href="#mysql使用远程登录的配置修改"></a> MySQL使用远程登录的配置修改</h1>
<ol>
<li>
<p>进入配置文件修改相应配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注释掉<code>bind-address = 127.0.0.1</code>(前面加#号)，保存并退出</p>
</li>
<li>
<p>进入数据库执行授权命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># %表示任意ip可登录</span><br><span class="line">mysql&gt; grant all on *.* to &lt;数据库用户名&gt;@&#x27;%&#x27; identified by &#x27;&lt;用户密码&gt;&#x27; with grant option;</span><br><span class="line"></span><br><span class="line"># 刷新权限</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line"></span><br><span class="line"># 退出MySQL</span><br><span class="line">mysql&gt; exit;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重启MySQL</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart mysql</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="mysql部分操作"><a class="markdownIt-Anchor" href="#mysql部分操作"></a> MySQL部分操作</h1>
<ol>
<li>
<p>进入数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo mysql -u root -p</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>退出数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1</span><br><span class="line">mysql&gt; quit;</span><br><span class="line">#2</span><br><span class="line">mysql&gt; exit;</span><br><span class="line">#3</span><br><span class="line">CTRL-D</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>显示所有数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create database school;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改数据库的字符集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter database school character set utf8;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; drop database school;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; use school;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table student (</span><br><span class="line">    -&gt; id int,</span><br><span class="line">    -&gt; name char(20),</span><br><span class="line">    -&gt; age int,</span><br><span class="line">    -&gt; score float);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; drop table student;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查看表结构信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show create table student;</span><br><span class="line">#或者</span><br><span class="line">mysql&gt; desc student;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查看当前数据库中所有表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改表，表的字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#change可以改变列名，同样可以改变类型， 但是不能单独去修改类型， modify只可以修改类型，不能修改名字</span><br><span class="line">mysql&gt; alter table student modify score int;</span><br><span class="line">mysql&gt; alter table student change name mingzi int;</span><br><span class="line">mysql&gt; alter table student change mingzi name varchar(20);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改表名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; rename table student to stu;</span><br><span class="line">mysql&gt; alter table stu rename to student;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在表中插入字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table student add english float;</span><br><span class="line">mysql&gt; alter table student add chinese float first;# 插入到第一列</span><br><span class="line">mysql&gt; alter table student add cs float after math;# 插入到math后面</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除表中的字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table student drop cs;</span><br><span class="line">mysql&gt; alter table student drop english;</span><br><span class="line">mysql&gt; alter table student drop chinese;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>向表中插入数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into student (id, name, age, math) </span><br><span class="line">    -&gt; values (1, &#x27;zhangsan&#x27;, 18, 80);</span><br><span class="line">#也可以向表中插入部分数据</span><br><span class="line">mysql&gt; insert into student (id, name, math) </span><br><span class="line">    -&gt; values (2, &#x27;libowen&#x27;, 100);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询表中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+------+----------+------+------+</span><br><span class="line">| id   | name     | age  | math |</span><br><span class="line">+------+----------+------+------+</span><br><span class="line">|    1 | zhangsan |   18 |   80 |</span><br><span class="line">|    2 | libowen  | NULL |  100 |</span><br><span class="line">+------+----------+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不写列名插入数据，必须把所有值按顺序赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into student values (3, &#x27;lile&#x27;, 24, 59);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>快速插入多条数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into student values (4, &#x27;xienan&#x27;, 18, 90), (5, &#x27;gougou&#x27;, 23, 5);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改表中元素值，更新数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table student add art float;</span><br><span class="line">mysql&gt; update student set art = 100 where id = 4;</span><br><span class="line">mysql&gt; update student set age = 23 where id = 2;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>一次更新多个数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; update student set age = 3, math = 10, art = 20 where name = &#x27;gougou&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除表中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; delete from student where name = &#x27;zhangsan&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以对表中插入空值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into student (id) values (NULL);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除表中的空值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; delete from student where id is NULL;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询表中单个数据的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select name from student;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询表中部分数据的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select name, art from student;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对查询结果去重</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; update student set age = 24 where name = &#x27;gougou&#x27;;</span><br><span class="line">mysql&gt; select distinct age from student;</span><br><span class="line">+------+</span><br><span class="line">| age  |</span><br><span class="line">+------+</span><br><span class="line">|   23 |</span><br><span class="line">|   24 |</span><br><span class="line">|   18 |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对查询结果做表达式运算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select name, math + 20 from student;</span><br><span class="line">+---------+-----------+</span><br><span class="line">| name    | math + 20 |</span><br><span class="line">+---------+-----------+</span><br><span class="line">| libowen |       120 |</span><br><span class="line">| lile    |        79 |</span><br><span class="line">| xienan  |       110 |</span><br><span class="line">| gougou  |        30 |</span><br><span class="line">+---------+-----------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对表达式取别名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select name, math + 20 as math2 from student;</span><br><span class="line">+---------+-------+</span><br><span class="line">| name    | math2 |</span><br><span class="line">+---------+-------+</span><br><span class="line">| libowen |   120 |</span><br><span class="line">| lile    |    79 |</span><br><span class="line">| xienan  |   110 |</span><br><span class="line">| gougou  |    30 |</span><br><span class="line">+---------+-------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询某些特定的列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student where age &gt; 18;</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">| id   | name    | age  | math | art  |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">|    2 | libowen |   23 |  100 | NULL |</span><br><span class="line">|    3 | lile    |   24 |   59 | NULL |</span><br><span class="line">|    5 | gougou  |   24 |   10 |   20 |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from student where age &lt; 24;</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">| id   | name    | age  | math | art  |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">|    2 | libowen |   23 |  100 | NULL |</span><br><span class="line">|    4 | xienan  |   18 |   90 |  100 |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from student where age != 18;</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">| id   | name    | age  | math | art  |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">|    2 | libowen |   23 |  100 | NULL |</span><br><span class="line">|    3 | lile    |   24 |   59 | NULL |</span><br><span class="line">|    5 | gougou  |   24 |   10 |   20 |</span><br><span class="line">+------+---------+------+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询某范围的数据between …  and … 查询范围是闭区间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student where math between 60 and 100;</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">| id   | name    | age  | math | art  |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">|    2 | libowen |   23 |  100 | NULL |</span><br><span class="line">|    4 | xienan  |   18 |   90 |  100 |</span><br><span class="line">+------+---------+------+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询集合中的数据<code>in（set）</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student where age in (18, 24);</span><br><span class="line">+------+--------+------+------+------+</span><br><span class="line">| id   | name   | age  | math | art  |</span><br><span class="line">+------+--------+------+------+------+</span><br><span class="line">|    3 | lile   |   24 |   59 | NULL |</span><br><span class="line">|    4 | xienan |   18 |   90 |  100 |</span><br><span class="line">|    5 | gougou |   24 |   10 |   20 |</span><br><span class="line">+------+--------+------+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>模糊查询<code>like</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student where name like &#x27;%nan&#x27;;</span><br><span class="line">+------+--------+------+------+------+</span><br><span class="line">| id   | name   | age  | math | art  |</span><br><span class="line">+------+--------+------+------+------+</span><br><span class="line">|    4 | xienan |   18 |   90 |  100 |</span><br><span class="line">+------+--------+------+------+------+</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from student where name like &#x27;%l_&#x27;;</span><br><span class="line">+------+------+------+------+------+</span><br><span class="line">| id   | name | age  | math | art  |</span><br><span class="line">+------+------+------+------+------+</span><br><span class="line">|    3 | lile |   24 |   59 | NULL |</span><br><span class="line">+------+------+------+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询多个条件同时成立<code>and</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student where name = &#x27;gougou&#x27; and age = 24;</span><br><span class="line">+------+--------+------+------+------+</span><br><span class="line">| id   | name   | age  | math | art  |</span><br><span class="line">+------+--------+------+------+------+</span><br><span class="line">|    5 | gougou |   24 |   10 |   20 |</span><br><span class="line">+------+--------+------+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询多个条件任一成立<code>or</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student where name = &#x27;gougou&#x27; or age = 23;</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">| id   | name    | age  | math | art  |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">|    2 | libowen |   23 |  100 | NULL |</span><br><span class="line">|    5 | gougou  |   24 |   10 |   20 |</span><br><span class="line">+------+---------+------+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询条件不成立的项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student where not (name = &#x27;xienan&#x27;);</span><br><span class="line">mysql&gt; select * from student where not name = &#x27;xienan&#x27;;</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">| id   | name    | age  | math | art  |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">|    2 | libowen |   23 |  100 | NULL |</span><br><span class="line">|    3 | lile    |   24 |   59 | NULL |</span><br><span class="line">|    5 | gougou  |   24 |   10 |   20 |</span><br><span class="line">+------+---------+------+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对查询结果排序（默认升序）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student order by age;</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">| id   | name    | age  | math | art  |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">|    4 | xienan  |   18 |   90 |  100 |</span><br><span class="line">|    2 | libowen |   23 |  100 | NULL |</span><br><span class="line">|    3 | lile    |   24 |   59 | NULL |</span><br><span class="line">|    5 | gougou  |   24 |   10 |   20 |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">#逆序</span><br><span class="line">mysql&gt; select * from student order by age desc;</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">| id   | name    | age  | math | art  |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">|    3 | lile    |   24 |   59 | NULL |</span><br><span class="line">|    5 | gougou  |   24 |   10 |   20 |</span><br><span class="line">|    2 | libowen |   23 |  100 | NULL |</span><br><span class="line">|    4 | xienan  |   18 |   90 |  100 |</span><br><span class="line">+------+---------+------+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>显示固定数量的数据<code>limit</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student order by age desc limit 3;</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">| id   | name    | age  | math | art  |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">|    3 | lile    |   24 |   59 | NULL |</span><br><span class="line">|    5 | gougou  |   24 |   10 |   20 |</span><br><span class="line">|    2 | libowen |   23 |  100 | NULL |</span><br><span class="line">+------+---------+------+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对查询结果进行偏移<code>offset</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student order by age desc limit 1 offset 2;</span><br><span class="line">#像后偏移了两个数据</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">| id   | name    | age  | math | art  |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">|    2 | libowen |   23 |  100 | NULL |</span><br><span class="line">+------+---------+------+------+------+</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>数据的完整性：</p>
<ol>
<li>实体完整性：通过主键保证插入的数据（一行）是表中唯一的实体，防止重复插入数据，浪费空间。</li>
<li>域完整性：保证列的数据类型和约束。</li>
<li>参照完整性：保证一个表的外键与另外 一个表的主键相关联，要求关系中不允许引用不存在的实体。</li>
</ol>
<p>数据完整性只能尽量的保证插入的数据是正确的，不能百分百保证数据的正确。</p>
<p>多表设计：</p>
<ol>
<li>一对多：避免数据的冗余，节约空间。</li>
<li>多对多：避免数据的荣誉，节约空间。</li>
<li>一对一：为了方便扩展，可以扩展成一对多，也可以扩展成多对多。</li>
</ol>
</blockquote>
<ol start="39">
<li>
<p>创建新表，设置主键，主键不能为NULL，不能为重复值，将主键设置为自动增长</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table teacher (</span><br><span class="line">    # auto_increment 实现自动增长功能</span><br><span class="line">    -&gt; id int auto_increment,</span><br><span class="line">    -&gt; name varchar(20),</span><br><span class="line">    -&gt; age int,</span><br><span class="line">    # 设置id为主键</span><br><span class="line">    -&gt; primary key(id)</span><br><span class="line">    -&gt; );</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>某字段设置为自动增长后，不赋值该字段，那么它会接着之前表中已有最大的值继续增加。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into teacher (name, age) values (&#x27;ma&#x27;, 28), (&#x27;liao&#x27;, 30), (&#x27;wang&#x27;, 31);</span><br><span class="line">mysql&gt; select * from teacher;</span><br><span class="line">+----+------+------+</span><br><span class="line">| id | name | age  |</span><br><span class="line">+----+------+------+</span><br><span class="line">|  1 | ma   |   28 |</span><br><span class="line">|  2 | liao |   30 |</span><br><span class="line">|  3 | wang |   31 |</span><br><span class="line">+----+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建新表，并设置外键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table project (</span><br><span class="line">    -&gt; id int auto_increment primary key,</span><br><span class="line">    -&gt; name varchar(20),</span><br><span class="line">    -&gt; teacher_id int,</span><br><span class="line">    -&gt; foreign key(teacher_id) references teacher(id)</span><br><span class="line">	-&gt; );</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>复制表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#只复制表数据，不复制表结构</span><br><span class="line">mysql&gt; create table teacher1 select * from teacher;</span><br><span class="line">#只复制表结构，不复制表中数据</span><br><span class="line">mysql&gt; create table teacher2 like teacher;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对一个没有设置主键的表设置主键</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> student modify id <span class="type">int</span> <span class="keyword">primary</span> key;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对一个没有外键的表设置外键，设置外键的时候， 关联的必须是另一个表的主键，而且类型需要相同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table student add teacher_id int;</span><br><span class="line">mysql&gt; alter table student add foreign key(teacher_id) references teacher(id); </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>主动设置外键名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table student add CONSTRAINT student_foreign_key FOREIGN KEY(teacher_id) REFERENCES teacher(id);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除外键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table student drop FOREIGN KEY teacher_id;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查看当前工作数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select database();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除主键，如果有外键关联该表的主键，是不能删除该表的主键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table student drop primary key;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>交叉查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student cross join teacher;</span><br><span class="line">+----+---------+------+------+------+------------+----+------+------+</span><br><span class="line">| id | name    | age  | math | art  | teacher_id | id | name | age  |</span><br><span class="line">+----+---------+------+------+------+------------+----+------+------+</span><br><span class="line">|  2 | libowen |   23 |  100 | NULL |       NULL |  1 | ma   |   28 |</span><br><span class="line">|  2 | libowen |   23 |  100 | NULL |       NULL |  2 | liao |   30 |</span><br><span class="line">|  2 | libowen |   23 |  100 | NULL |       NULL |  3 | wang |   31 |</span><br><span class="line">|  3 | lile    |   24 |   59 | NULL |       NULL |  1 | ma   |   28 |</span><br><span class="line">|  3 | lile    |   24 |   59 | NULL |       NULL |  2 | liao |   30 |</span><br><span class="line">|  3 | lile    |   24 |   59 | NULL |       NULL |  3 | wang |   31 |</span><br><span class="line">|  4 | xienan  |   18 |   90 |  100 |       NULL |  1 | ma   |   28 |</span><br><span class="line">|  4 | xienan  |   18 |   90 |  100 |       NULL |  2 | liao |   30 |</span><br><span class="line">|  4 | xienan  |   18 |   90 |  100 |       NULL |  3 | wang |   31 |</span><br><span class="line">|  5 | gougou  |   24 |   10 |   20 |       NULL |  1 | ma   |   28 |</span><br><span class="line">|  5 | gougou  |   24 |   10 |   20 |       NULL |  2 | liao |   30 |</span><br><span class="line">|  5 | gougou  |   24 |   10 |   20 |       NULL |  3 | wang |   31 |</span><br><span class="line">+----+---------+------+------+------+------------+----+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>内连接查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student cross join teacher on student.id = teacher.id;</span><br><span class="line">+----+---------+------+------+------+------------+----+------+------+</span><br><span class="line">| id | name    | age  | math | art  | teacher_id | id | name | age  |</span><br><span class="line">+----+---------+------+------+------+------------+----+------+------+</span><br><span class="line">|  2 | libowen |   23 |  100 | NULL |       NULL |  2 | liao |   30 |</span><br><span class="line">|  3 | lile    |   24 |   59 | NULL |       NULL |  3 | wang |   31 |</span><br><span class="line">+----+---------+------+------+------+------------+----+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>隐式内连接不加inner join</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from teacher, student where student.id = teacher.stu_id;</span><br><span class="line">+----+------+--------+--------+----+------+------+-------+</span><br><span class="line">| id | name | pro_id | stu_id | id | name | age  | score |</span><br><span class="line">+----+------+--------+--------+----+------+------+-------+</span><br><span class="line">|  1 | ma   |      1 |      1 |  1 | xx   |   18 |    88 |</span><br><span class="line">+----+------+--------+--------+----+------+------+-------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以对查询的表名起别名as</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from teacher as t inner join student as s on s.id = t.stu_id;</span><br><span class="line">+----+------+--------+--------+----+------+------+-------+</span><br><span class="line">| id | name | pro_id | stu_id | id | name | age  | score |</span><br><span class="line">+----+------+--------+--------+----+------+------+-------+</span><br><span class="line">|  1 | ma   |      1 |      1 |  1 | xx   |   18 |    88 |</span><br><span class="line">+----+------+--------+--------+----+------+------+-------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>左外连接（以左表为基准）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student left outer join teacher on student.id = teacher.stu_id;</span><br><span class="line">+----+------+------+-------+------+------+--------+--------+</span><br><span class="line">| id | name | age  | score | id   | name | pro_id | stu_id |</span><br><span class="line">+----+------+------+-------+------+------+--------+--------+</span><br><span class="line">|  1 | xx   |   18 |    88 |    1 | ma   |      1 |      1 |</span><br><span class="line">+----+------+------+-------+------+------+--------+--------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>右外连接（以右表为基准）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student right outer join teacher on student.id = teacher.stu_id;</span><br><span class="line">+------+------+------+-------+----+------+--------+--------+</span><br><span class="line">| id   | name | age  | score | id | name | pro_id | stu_id |</span><br><span class="line">+------+------+------+-------+----+------+--------+--------+</span><br><span class="line">|    1 | xx   |   18 |    88 |  1 | ma   |      1 |      1 |</span><br><span class="line">+------+------+------+-------+----+------+--------+--------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>子查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student where id = (select id from student where name like &#x27;%x&#x27;);</span><br><span class="line">+----+------+------+-------+</span><br><span class="line">| id | name | age  | score |</span><br><span class="line">+----+------+------+-------+</span><br><span class="line">|  1 | xx   |   18 |    88 |</span><br><span class="line">+----+------+------+-------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>联合查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select score from student where id &gt; 2 union select score from student where score &lt; 90;</span><br><span class="line">+-------+</span><br><span class="line">| score |</span><br><span class="line">+-------+</span><br><span class="line">|    68 |</span><br><span class="line">|    88 |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对联合查询结果不去重union all</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select score from student where id &gt; 2 union all select score from student where score &lt; 90;   </span><br><span class="line">+-------+</span><br><span class="line">| score |</span><br><span class="line">+-------+</span><br><span class="line">|    68 |</span><br><span class="line">|    88 |</span><br><span class="line">|    68 |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>报表查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select age from student group by age;</span><br><span class="line">+------+</span><br><span class="line">| age  |</span><br><span class="line">+------+</span><br><span class="line">|   18 |</span><br><span class="line">|   20 |</span><br><span class="line">|   22 |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>统计函数和报表查询联合使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#group by后面的组要是同样的， 不然查不到</span><br><span class="line">mysql&gt; select count(age),age from student group by age;</span><br><span class="line">+------------+------+</span><br><span class="line">| count(age) | age  |</span><br><span class="line">+------------+------+</span><br><span class="line">|          1 |   18 |</span><br><span class="line">|          1 |   20 |</span><br><span class="line">|          1 |   22 |</span><br><span class="line">+------------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询表中最大和最小的年纪</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select max(age),min(age) from student;</span><br><span class="line">+----------+----------+</span><br><span class="line">| max(age) | min(age) |</span><br><span class="line">+----------+----------+</span><br><span class="line">|       22 |       18 |</span><br><span class="line">+----------+----------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对报表查询做条件查询group by … having …</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#用insert into加了一点数据</span><br><span class="line">mysql&gt; select count(age), age from student group by age having age &lt; 25;</span><br><span class="line">+------------+------+</span><br><span class="line">| count(age) | age  |</span><br><span class="line">+------------+------+</span><br><span class="line">|          1 |    7 |</span><br><span class="line">|          1 |    8 |</span><br><span class="line">|          1 |   18 |</span><br><span class="line">|          1 |   20 |</span><br><span class="line">|          2 |   21 |</span><br><span class="line">|          1 |   22 |</span><br><span class="line">+------------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对查询出来的临时表再次查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select count(age), age from student group by age having count(age) &gt; 1;</span><br><span class="line">+------------+------+</span><br><span class="line">| count(age) | age  |</span><br><span class="line">+------------+------+</span><br><span class="line">|          2 |   21 |</span><br><span class="line">|          2 |   26 |</span><br><span class="line">+------------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>数据库的备份和恢复</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 备份</span></span><br><span class="line">sudo mysqldump -u root -p school &gt; school.sql</span><br><span class="line"><span class="comment"># 恢复，得先建库（create database  + 库名）</span></span><br><span class="line">sudo mysql -u root -p school &lt; school.sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编译数据库代码需要加动态库<code>-lmysqlclient</code></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>线程</title>
    <url>/2021/07/14/%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="进程与线程的特点与区别"><a class="markdownIt-Anchor" href="#进程与线程的特点与区别"></a> 进程与线程的特点与区别</h1>
<ol>
<li>进程：资源分配的基本单位（最小单位），拥有自己独立的资源，如自己独立的数据段、代码段和堆栈段，所以在CPU进行进程切换时需要保存大量的上下文<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，需要大量的时间开销。<strong>为了减少这一时间开销，因此引入了线程。</strong>
<ul>
<li>创建：<code>fork()</code></li>
<li>退出：<code>exit()</code></li>
<li>等待：<code>wait()</code></li>
</ul>
</li>
<li>线程：CPU调度的基本单位，一个进程至少拥有一个线程。一个进程中的多个线程会共享该进程的地址空间。线程只拥有少量的栈空间。线程的缺点：不利于资源的管理和保护<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。
<ul>
<li>创建：<code>pthread_create()</code></li>
<li>退出：<code>pthread_exit()</code></li>
<li>等待：<code>pthread_join()</code></li>
</ul>
<span id="more"></span>
</li>
<li>用比喻理解两者关系：进程就好比一个学校的某一间宿舍，线程就好比该宿舍中的某个人。</li>
<li>查看进程相关信息的命令：<code>ps -elf</code></li>
<li>查看线程相关信息的命令：<code>ps -elLf</code>（查看的时核心级线程id）</li>
</ol>
<h1 id="线程的种类"><a class="markdownIt-Anchor" href="#线程的种类"></a> 线程的种类</h1>
<ol>
<li>用户级：用户自己创建的线程。</li>
<li>核心级：CPU实际运行的线程。</li>
</ol>
<h1 id="线程的一些操作"><a class="markdownIt-Anchor" href="#线程的一些操作"></a> 线程的一些操作</h1>
<ol>
<li>
<p>线程的创建：<code>int pthread_create(pthread_t *thread, const pthread_attr_t attr, void *(*start_routine)(void *), void *arg)</code></p>
<ul>
<li>
<p>返回值：成功返回0，失败返回错误码。</p>
</li>
<li>
<p>参数1：线程id。</p>
</li>
<li>
<p>参数2：线程的属性，没有特殊设置填NULL。</p>
</li>
<li>
<p>参数3：线程的处理函数，注意函数类型为void *型。</p>
</li>
<li>
<p>参数4：线程处理函数的参数。</p>
</li>
</ul>
</li>
<li>
<p>线程的等待：<code>int pthread_join(pthread_t thread, void **retval)</code></p>
<ul>
<li>返回值：成功返回0，失败返回错误码。</li>
<li>参数1：等待退出的线程id。</li>
<li>参数2：接收子线程的退出，可以接收指针类型的退出状态，也可以接收long类型的变量。</li>
</ul>
</li>
<li>
<p>线程的退出：<code>int pthread_exit(void *retval)</code></p>
<ul>
<li>返回值：使用函数的返回值作为线程的退出状态。（函数说明直译的，一般没啥用）</li>
<li>参数：指向线程thread的返回值，一般填NULL。</li>
</ul>
</li>
<li>
<p>线程id的获取：<code>pthread_t pthread_self(void)</code>，永远不会失败，成功返回线程id。</p>
</li>
<li>
<p>线程的取消：</p>
<ol>
<li>线程可以自己调用线程退出函数退出，也可以被其他线程杀掉，被其他线程杀掉的方式就叫做线程的取消。</li>
<li>被杀掉的线程可以选择自己如何处理这个信号，如：忽略、立即终止、运行到<strong>取消点</strong>后终止。</li>
<li>取消点：就是一些特殊函数：一般的阻塞性函数都是取消点，非阻塞性函数也有可能是取消点。</li>
<li>线程取消函数：<code>int pthread_cancel(pthread_t thread)</code>
<ul>
<li>返回值：成功返回0，失败返回错误码。</li>
<li>想要cancel掉的线程id。</li>
</ul>
</li>
</ol>
</li>
</ol>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>—个进程的上下文(context)包括进程的状态、有关变量和数据结构的值、机器寄存器的值和PCB以及有关程序、数据等。一个进程的执行是在进程的上下文中执行。当正在执行的进程由于某种原因要让出处理机时，系统要做进程上下文切换，以使另一个进程得以执行。当进行上下文切换时点统要首先检查是否允许做上下文切换(在有些情况下，上下文切换是不允许的，例如系统正在执行某个不允许中断的原语时)。然后，系统要保留有关被切换进程的足够信息，以便以后切换回该进程时，顺利恢复该进程的执行。在系统保留了CPU现场之后，调度程序选择一个新的处于就绪状态的进程、并装配该进程的上下文，使CPU的控制权掌握在被选中进程手中。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>线程上锁后如果崩溃了，那么资源无法得到释放，其他线程都无法继续正常执行 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2021/07/15/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h1>
<p>使用线程池的好处：</p>
<ol>
<li>降低资源的消耗，多个线程能共享同一个进程的内存空间。</li>
<li>提高响应速度，任务来时能直接响应不需要等待。</li>
<li>提高现成的可管理性，线程不能无限制创建，有数量限制。
<ul>
<li>对于IO密集型的任务：线程数量一般等于CPU核心数的二倍。</li>
<li>对于CPU密集型的任务：线程的数量一般等于CPU核心数+1。</li>
</ul>
</li>
</ol>
<span id="more"></span>
<h2 id="程序运行流程"><a class="markdownIt-Anchor" href="#程序运行流程"></a> 程序运行流程</h2>
<ol>
<li>主线程：
<ol>
<li>创建线程池，初始化。</li>
<li>线程池启动，创建制定数量的线程。</li>
<li>服务器绑定tcp通信套接字。</li>
<li>创建epoll，并将需要监听的tcp通信套接字放入epoll。</li>
<li><code>accept()</code>函数等待客户端连接。</li>
<li>接收客户端连接，创建任务队列中的任务节点，将用于与客户端连接的通信描述符存入任务节点，再将任务节点放入任务队列，队列长度＋1。并激发所有的条件变量。</li>
<li>回到步骤5等待下一次客户端请求连接。</li>
</ol>
</li>
<li>子线程：
<ol>
<li>队列上锁，进入<code>pthread_cond_wait()</code>函数。</li>
<li>等待主线程激发。</li>
<li>子线程被激发，抢到任务队列中的任务节点，任务节点出队，队列长度－1，解锁。</li>
<li>用任务节点中的文件描述符服务客户端，服务完关闭文件描述符。</li>
<li>回到步骤1等待下一次任务。</li>
</ol>
</li>
</ol>
<h2 id="程序的退出"><a class="markdownIt-Anchor" href="#程序的退出"></a> 程序的退出</h2>
<ol>
<li>主线程：
<ol>
<li>收到退出信号，通过信号处理函数对退出管道进行写数据。</li>
<li>epoll监听到，主线程将任务队列中的退出标识位置1，并激发所有条件变量。</li>
<li>等到所有子线程退出后主线程再退出。</li>
</ol>
</li>
<li>子线程：
<ol>
<li>队列上锁，进入<code>pthread_cond_wait()</code>函数。</li>
<li>等待主线程激发。</li>
<li>子线程被激发，发现任务队列中推出标识位为1，进行线程的退出。</li>
</ol>
</li>
</ol>
<h2 id="数据结构设计"><a class="markdownIt-Anchor" href="#数据结构设计"></a> 数据结构设计</h2>
<ol>
<li>
<p>线程池结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程池结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">//线程个数</span></span><br><span class="line">    <span class="keyword">int</span> thread_num;</span><br><span class="line">    <span class="comment">//线程id数组，动态创建</span></span><br><span class="line">    <span class="keyword">pthread_t</span> *pThread_id;</span><br><span class="line">    <span class="comment">//任务队列</span></span><br><span class="line">    <span class="keyword">task_que_t</span> task_que;</span><br><span class="line">&#125;<span class="keyword">thread_pool_t</span>, *pThread_pool_t;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>任务队列结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//任务队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_que_s</span>&#123;</span></span><br><span class="line">    <span class="comment">//退出信号</span></span><br><span class="line">    <span class="keyword">short</span> exit_flag;</span><br><span class="line">    <span class="comment">//任务队列长度</span></span><br><span class="line">    <span class="keyword">int</span> que_len;</span><br><span class="line">    <span class="comment">//线程的条件变量</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> que_cond;</span><br><span class="line">    <span class="comment">//线程锁</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> que_mutex;</span><br><span class="line">    <span class="comment">//任务队列的首尾指针</span></span><br><span class="line">    pTask_node_t pHead, pTail;</span><br><span class="line">&#125;<span class="keyword">task_que_t</span>, *pTask_que_t;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>任务节点结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个任务中存储与客户端通信的文件描述符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_node_s</span>&#123;</span></span><br><span class="line">    <span class="comment">//与客户端通信的文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> client_fd;</span><br><span class="line">    <span class="comment">//下一个任务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_node_s</span> *<span class="title">pNext</span>;</span></span><br><span class="line">&#125;<span class="keyword">task_node_t</span>, *pTask_node_t;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>传输数据结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于传输数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data_len;</span><br><span class="line">    <span class="keyword">char</span> data_buf[<span class="number">1000</span>];</span><br><span class="line">&#125;<span class="keyword">train_t</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="主程序设计"><a class="markdownIt-Anchor" href="#主程序设计"></a> 主程序设计</h2>
<h3 id="mainc主程序"><a class="markdownIt-Anchor" href="#mainc主程序"></a> main.c:主程序</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../head/func.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../head/taskque.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../head/threadpoll.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> out_pipe[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main_sigfunc</span><span class="params">(<span class="keyword">int</span> signum)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sig = %d is coming\n&quot;</span>, signum);</span><br><span class="line">    write(out_pipe[<span class="number">1</span>], <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//./server_pool ip port pthread_num</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    signal(<span class="number">10</span>, main_sigfunc);</span><br><span class="line">    pipe(out_pipe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fork())&#123;</span><br><span class="line">        <span class="comment">//主进程关闭读端</span></span><br><span class="line">        close(out_pipe[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待子进程的退出然后退出</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main out\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子进程关闭写端</span></span><br><span class="line">    close(out_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pthread_num = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">//创建进程池结构体，不是指针！</span></span><br><span class="line">    <span class="keyword">thread_pool_t</span> pool;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;pool, <span class="number">0</span>, <span class="keyword">sizeof</span>(pool));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.初始化线程池，创建pthread_num个线程空间，创建任务队列</span></span><br><span class="line">    ret = ThreadPoolInit(&amp;pool, pthread_num);</span><br><span class="line">    THREAD_ERROR_CHECK(ret, <span class="string">&quot;ThreadPoolInit&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.开启线程池，创建线程，接收任务</span></span><br><span class="line">    ret = ThreadPoolCreate(&amp;pool);</span><br><span class="line">    THREAD_ERROR_CHECK(ret, <span class="string">&quot;ThreadPoolCreate&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.创建Tcp套接字监听连接</span></span><br><span class="line">    <span class="keyword">int</span> socket_fd = <span class="number">0</span>;</span><br><span class="line">    ret = TcpInit(argv[<span class="number">1</span>], argv[<span class="number">2</span>], &amp;socket_fd);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;TcpInit&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.创建epoll，参数只要大于0就行，并将需要监听的文件描述符添加到epoll中</span></span><br><span class="line">    <span class="keyword">int</span> epoll_fd = epoll_create(<span class="number">1</span>);</span><br><span class="line">    ret = EpollAddFd(epoll_fd, socket_fd);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;EpollAddFd&quot;</span>);</span><br><span class="line">    ret = EpollAddFd(epoll_fd, out_pipe[<span class="number">0</span>]);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;EpollAddFd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//epoll结构体，存放就绪文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span>[2];</span></span><br><span class="line">    <span class="built_in">memset</span>(evs, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct epoll_event));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//-1表示无条件等待</span></span><br><span class="line">        <span class="keyword">int</span> ready_num = epoll_wait(epoll_fd, evs, <span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ready_num; ++i)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(evs[i].data.fd == out_pipe[<span class="number">0</span>])&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//修改任务队列中的退出标号为1</span></span><br><span class="line">                pthread_mutex_lock(&amp;pool.task_que.que_mutex);</span><br><span class="line">                pool.task_que.exit_flag = <span class="number">1</span>;</span><br><span class="line">                pthread_mutex_unlock(&amp;pool.task_que.que_mutex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//激发全部条件变量</span></span><br><span class="line">                ret = pthread_cond_broadcast(&amp;pool.task_que.que_cond);</span><br><span class="line">                THREAD_ERROR_CHECK(ret, <span class="string">&quot;pthread_cond_broadcast&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//等待线程退出</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pthread_num; ++j)&#123;</span><br><span class="line">                    pthread_join(pool.pThread_id[j], <span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child process exit\n&quot;</span>);</span><br><span class="line">                <span class="comment">//子进程退出</span></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(evs[i].data.fd == socket_fd)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//接收新连接的文件描述符</span></span><br><span class="line">                <span class="keyword">int</span> new_fd = accept(socket_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                ERROR_CHECK(new_fd, <span class="number">-1</span>, <span class="string">&quot;accept&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//保存文件描述符到任务节点</span></span><br><span class="line">                pTask_node_t pTask = (pTask_node_t)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">task_node_t</span>));</span><br><span class="line">                pTask-&gt;client_fd = new_fd;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//用这种方式申请的节点，不能用free释放，浪费内存空间</span></span><br><span class="line">                <span class="comment">/* //保存文件描述符到任务节点 */</span></span><br><span class="line">                <span class="comment">/* task_node_t task_node; */</span></span><br><span class="line">                <span class="comment">/* memset(&amp;task_node, 0, sizeof(task_node_t)); */</span></span><br><span class="line">                <span class="comment">/* task_node.client_fd = new_fd; */</span></span><br><span class="line">                <span class="comment">/* printf(&quot;node save fd = %d\n&quot;, task_node.client_fd); */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//加锁，互斥修改任务队列</span></span><br><span class="line">                pthread_mutex_lock(&amp;pool.task_que.que_mutex);</span><br><span class="line">                ret = InsertTaskQue(&amp;pool.task_que, pTask);</span><br><span class="line">                ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;InsertTaskQue&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//插入节点成功，激发所有条件变量</span></span><br><span class="line">                ret = pthread_cond_broadcast(&amp;pool.task_que.que_cond);</span><br><span class="line">                THREAD_ERROR_CHECK(ret, <span class="string">&quot;pthread_cond_broadcast&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//解锁</span></span><br><span class="line">                pthread_mutex_unlock(&amp;pool.task_que.que_mutex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="threadpoolc线程池相关函数"><a class="markdownIt-Anchor" href="#threadpoolc线程池相关函数"></a> ThreadPool.c：线程池相关函数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//void型的线程清理函数!</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clean_func</span><span class="params">(<span class="keyword">void</span> *p)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    pTask_que_t que = (pTask_que_t)p;</span><br><span class="line">    pthread_mutex_unlock(&amp;que-&gt;que_mutex);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_func</span><span class="params">(<span class="keyword">void</span> *p)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将传入进来的队列进行类型转换</span></span><br><span class="line">    pTask_que_t que = (pTask_que_t)p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建任务节点用取任务</span></span><br><span class="line">    pTask_node_t pTask = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取任务函数的返回值，0为失败，1为成功</span></span><br><span class="line">    <span class="keyword">int</span> get_success = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上锁互斥访问队列，如果之前上锁，则会阻塞</span></span><br><span class="line">        pthread_mutex_lock(&amp;que-&gt;que_mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清理函数紧贴要清理的资源，前面上锁了所以要在清理函数里面解锁</span></span><br><span class="line">        pthread_cleanup_push(clean_func, que);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果队列中没有节点</span></span><br><span class="line">        <span class="comment">//函数上半部做的是：1.条件变量上排队2.解锁3.睡眠等待激发</span></span><br><span class="line">        <span class="comment">//函数下半部做的是：1.被唤醒（激发）2.加锁，如果已经上锁，则阻塞至锁解锁，然后加锁3.pthread_cond_wait函数返回</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == que-&gt;que_len)&#123;</span><br><span class="line">            pthread_cond_wait(&amp;que-&gt;que_cond, &amp;que-&gt;que_mutex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//GetTaskNode取节点</span></span><br><span class="line">        get_success = GetTaskNode(que, &amp;pTask);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;que-&gt;que_mutex);</span><br><span class="line">        pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取节点成功，用文件描述符发送文件，任务完成释放节点资源，置为空指针</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == get_success)&#123;</span><br><span class="line">            TransFile(pTask-&gt;client_fd);</span><br><span class="line">            <span class="built_in">free</span>(pTask);</span><br><span class="line">            pTask = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == que-&gt;exit_flag)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;thread out\n&quot;</span>);</span><br><span class="line">            <span class="comment">//线程退出</span></span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ThreadPoolInit</span><span class="params">(pThread_pool_t pThreadPool, <span class="keyword">int</span> thread_num)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线程数量</span></span><br><span class="line">    pThreadPool-&gt;thread_num = thread_num;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为线程id申请空间</span></span><br><span class="line">    pThreadPool-&gt;pThread_id = (<span class="keyword">pthread_t</span> *)<span class="built_in">calloc</span>(thread_num, <span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务队列初始化</span></span><br><span class="line">    ret = TaskQueInit(&amp;pThreadPool-&gt;task_que);</span><br><span class="line">    THREAD_ERROR_CHECK(ret, <span class="string">&quot;TaskQueInit&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ThreadPoolCreate</span><span class="params">(pThread_pool_t pThreadPool)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环创建线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pThreadPool-&gt;thread_num; ++i)&#123;</span><br><span class="line">        <span class="comment">//两种方式</span></span><br><span class="line">        <span class="comment">/* ret = pthread_create(pThreadPool-&gt;pThread_id + i, NULL, thread_func, &amp;pThreadPool-&gt;task_que); */</span></span><br><span class="line">        ret = pthread_create(&amp;pThreadPool-&gt;pThread_id[i], <span class="literal">NULL</span>, thread_func, &amp;pThreadPool-&gt;task_que);</span><br><span class="line">        THREAD_ERROR_CHECK(ret, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="taskquec任务队列相关函数"><a class="markdownIt-Anchor" href="#taskquec任务队列相关函数"></a> TaskQue.c：任务队列相关函数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队列初始化函数，初始化任务队列中的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TaskQueInit</span><span class="params">(pTask_que_t pTaskQue)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    pTaskQue-&gt;que_len = <span class="number">0</span>;</span><br><span class="line">    pTaskQue-&gt;pHead = <span class="literal">NULL</span>;</span><br><span class="line">    pTaskQue-&gt;pTail = <span class="literal">NULL</span>;</span><br><span class="line">    ret = pthread_cond_init(&amp;pTaskQue-&gt;que_cond, <span class="literal">NULL</span>);</span><br><span class="line">    THREAD_ERROR_CHECK(ret, <span class="string">&quot;pthread_cond_init&quot;</span>);</span><br><span class="line">    ret = pthread_mutex_init(&amp;pTaskQue-&gt;que_mutex, <span class="literal">NULL</span>);</span><br><span class="line">    THREAD_ERROR_CHECK(ret, <span class="string">&quot;pthread_mutex_init&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队，尾插法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InsertTaskQue</span><span class="params">(pTask_que_t pTaskQue, pTask_node_t pTaskNode)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//任务队列中没有任务节点时，头尾指针指向新加入的任务节点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == pTaskQue-&gt;que_len)&#123;</span><br><span class="line">        pTaskQue-&gt;pHead = pTaskNode;</span><br><span class="line">        pTaskQue-&gt;pTail = pTaskNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有节点，尾插法</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        pTaskQue-&gt;pTail-&gt;pNext = pTaskNode;</span><br><span class="line">        pTaskQue-&gt;pTail = pTaskNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队后队列长度+1</span></span><br><span class="line">    ++pTaskQue-&gt;que_len;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队，头部删除法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTaskNode</span><span class="params">(pTask_que_t pTaskQue, pTask_node_t *pGetTaskNode)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有节点，头部删除法</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != pTaskQue-&gt;que_len)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//待取出的节点指向头指针</span></span><br><span class="line">        *pGetTaskNode = pTaskQue-&gt;pHead;</span><br><span class="line">        pTaskQue-&gt;pHead = pTaskQue-&gt;pHead-&gt;pNext;</span><br><span class="line">        (*pGetTaskNode)-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//出队后队列长度-1</span></span><br><span class="line">        --pTaskQue-&gt;que_len;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//取完后队列长度为0，把尾指针置空</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == pTaskQue-&gt;que_len)&#123;</span><br><span class="line">            pTaskQue-&gt;pTail = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没节点，返回0</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="tcpinitc-transfilec-epolladdfdc前文进程池中定义过的函数"><a class="markdownIt-Anchor" href="#tcpinitc-transfilec-epolladdfdc前文进程池中定义过的函数"></a> TcpInit.c、TransFile.c、EpollAddFd.c：前文进程池中定义过的函数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TcpInit</span><span class="params">(<span class="keyword">char</span> *ip, <span class="keyword">char</span>*port, <span class="keyword">int</span> *socket_fd)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="comment">/*分别设置协议、IP地址和端口号*/</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line">    addr.sin_port = htons(atoi(port));</span><br><span class="line"></span><br><span class="line">    *socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(*socket_fd, <span class="number">-1</span>, <span class="string">&quot;socket&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置地址可重用</span></span><br><span class="line">    <span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">    ret = setsockopt(*socket_fd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置缓冲区大小</span></span><br><span class="line">    <span class="keyword">int</span> buf = <span class="number">65536</span>;</span><br><span class="line">    ret = setsockopt(*socket_fd, SOL_SOCKET, SO_SNDBUF, &amp;buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绑定ip地址和端口号</span></span><br><span class="line">    ret = bind(*socket_fd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;bind&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听描述符，最大连接数设置为10</span></span><br><span class="line">    ret = listen(*socket_fd, <span class="number">10</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;ret&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigfunc</span><span class="params">(<span class="keyword">int</span> signum)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGPIPE is coming&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TransFile</span><span class="params">(<span class="keyword">int</span> client_fd)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    signal(SIGPIPE, sigfunc);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;1.pdf&quot;</span>, O_RDWR);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;open&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前文件的状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">fileInfo</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;fileInfo, <span class="number">0</span>, <span class="keyword">sizeof</span>(fileInfo));</span><br><span class="line">    ret = fstat(fd, &amp;fileInfo);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;fstat&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建传输数据结构体</span></span><br><span class="line">    <span class="keyword">train_t</span> train;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;train, <span class="number">0</span>, <span class="keyword">sizeof</span>(train));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送文件名</span></span><br><span class="line">    train.data_len = <span class="built_in">strlen</span>(<span class="string">&quot;1.pdf&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(train.data_buf, <span class="string">&quot;1.pdf&quot;</span>);</span><br><span class="line">    ret = send(client_fd, &amp;train, <span class="number">4</span> + train.data_len, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;send&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;train, <span class="number">0</span>, <span class="keyword">sizeof</span>(train));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送文件大小</span></span><br><span class="line">    train.data_len = <span class="keyword">sizeof</span>(fileInfo.st_size);</span><br><span class="line">    <span class="built_in">memcpy</span>(train.data_buf, &amp;fileInfo.st_size, <span class="keyword">sizeof</span>(<span class="keyword">off_t</span>));</span><br><span class="line">    send(client_fd, &amp;train, <span class="number">4</span> + train.data_len, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fileSize = %ld\n&quot;</span>, fileInfo.st_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> send_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    pipe(fds);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(send_size &lt; fileInfo.st_size)&#123;</span><br><span class="line">        ret = splice(fd, <span class="number">0</span>, fds[<span class="number">1</span>], <span class="number">0</span>, <span class="number">64</span>, <span class="number">0</span>);</span><br><span class="line">        ret = splice(fds[<span class="number">0</span>], <span class="number">0</span>, client_fd, <span class="number">0</span>, ret, <span class="number">0</span>);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;splice&quot;</span>);</span><br><span class="line">        send_size += ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fds[<span class="number">0</span>]);</span><br><span class="line">    close(fds[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EpollAddFd</span><span class="params">(<span class="keyword">int</span> epoll_fd, <span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;events, <span class="number">0</span>, <span class="keyword">sizeof</span>(events));</span><br><span class="line"></span><br><span class="line">    events.events = EPOLLIN;</span><br><span class="line">    events.data.fd = fd;</span><br><span class="line"></span><br><span class="line">    ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;events);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="客户端用前文进程池的客户端即可"><a class="markdownIt-Anchor" href="#客户端用前文进程池的客户端即可"></a> 客户端：用前文进程池的客户端即可</h3>
<h1 id="遇到的问题"><a class="markdownIt-Anchor" href="#遇到的问题"></a> 遇到的问题</h1>
<ol>
<li>
<p>free任务节点空间时报错。</p>
<ul>
<li>原因：创建任务节点时，一开始用的是栈空间申请，子线程取节点服务完服务器后无法通过free释放节点空间，会报错。</li>
<li>解决办法：使用堆空间申请任务节点，使用完后能方便的清理空间。</li>
</ul>
</li>
<li>
<p>入队、出队的时候忘记对队列长度进程+1、-1操作，程序报错。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>进程池</title>
    <url>/2021/07/12/%E8%BF%9B%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="进程池"><a class="markdownIt-Anchor" href="#进程池"></a> 进程池</h1>
<ul>
<li>
<p>目的：实现多个客户端同时访问服务器获得服务(本文例子为下载文件)</p>
</li>
<li>
<p>好处：1. 降低资源消耗；2. 提高响应速度；3. 提高进程的可管理性。</p>
</li>
</ul>
<span id="more"></span>
<h2 id="主要工作流程"><a class="markdownIt-Anchor" href="#主要工作流程"></a> 主要工作流程：</h2>
<ul>
<li>父进程：
<ol>
<li>循环创建子进程，记录子进程的相关信息(子进程进程ID，进程的状态，子进程与服务端通信时的文件描述符)。查看是否创建成功：<code>ps -elf | grep [端口号]</code>可以查看子进程是否创建成功。</li>
<li>创建TCP监听套接字，等待客户端的连接请求，查看是否再监听：<code>netstat -nat</code>需要安装。</li>
<li>创建epoll，把需要监听的文件描述符都添加到epoll中，子进程与服务器通信的文件描述符也要加入到epoll当中。</li>
<li>如果客户端请求服务器，使用accept函数接收这次连接请求并返回一个用于与客户端通信的文件描述符，将其发送给子进程(使用sendmsg发送，需要一个msg结构体)，让子进程用该文件描述符与其通信，服务客户端，并将子进程状态设置为忙碌。—&gt;转到子进程。</li>
<li>如果epoll监听到子进程发送的结束信息，主进程将子进程状态设置为不忙碌。</li>
</ol>
</li>
<li>子进程：
<ol>
<li>子进程阻塞，等待父进程发送与客户端相互通信的文件描述符(使用recvmsg函数接收)，用于服务客户端。</li>
<li>服务完客户端之后，关闭与客户端的连接，通知父进程，由父进程将子进程的工作状态设置为不忙碌。</li>
<li>继续等待下一次任务。</li>
</ol>
</li>
</ul>
<h2 id="客户端从服务器下载文件流程"><a class="markdownIt-Anchor" href="#客户端从服务器下载文件流程"></a> 客户端从服务器下载文件流程：</h2>
<ul>
<li>服务器：
<ol>
<li>发送文件名，打开文件。</li>
<li>读取文件，发送文件内容。</li>
</ol>
</li>
<li>客户端：
<ol>
<li>接收文件名，创建同名文件。</li>
<li>接收文件内容，写入同名文件。</li>
</ol>
</li>
<li>文件检测：用md5sum命令对文件计算哈希值，获得相同值说明文件传输成功。</li>
</ul>
<h1 id="服务器设计"><a class="markdownIt-Anchor" href="#服务器设计"></a> 服务器设计</h1>
<h2 id="数据结构设计"><a class="markdownIt-Anchor" href="#数据结构设计"></a> 数据结构设计：</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pipe_fd：与主进程进行通信的文件描述符</span></span><br><span class="line"><span class="comment">busy_status：子进程忙碌状态</span></span><br><span class="line"><span class="comment">pid：子进程的pid</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_BUSY 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_NO_BUSY 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">process_info_s</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> pipe_fd;</span><br><span class="line">    <span class="keyword">int</span> busy_status;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">&#125;<span class="keyword">process_info_t</span>, *pProcess_info_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">data_len：传输数据的长度</span></span><br><span class="line"><span class="comment">data_buf：传输的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data_len;</span><br><span class="line">    <span class="keyword">char</span> data_buf[<span class="number">1000</span>];</span><br><span class="line">&#125;<span class="keyword">train_t</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="程序设计"><a class="markdownIt-Anchor" href="#程序设计"></a> 程序设计：</h2>
<h3 id="mainc主程序"><a class="markdownIt-Anchor" href="#mainc主程序"></a> main.c：主程序</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.循环创建子进程，并记录子进程的相关信息</span></span><br><span class="line">    <span class="keyword">int</span> process_num = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">    pProcess_info_t pInfo = (pProcess_info_t)<span class="built_in">calloc</span>(process_num, <span class="keyword">sizeof</span>(<span class="keyword">process_info_t</span>));</span><br><span class="line">    ret = CreateProcess(pInfo, process_num);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;CreateProcess&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.创建tcp监听套接字，等待客户端连接</span></span><br><span class="line">    <span class="keyword">int</span> socket_fd = <span class="number">0</span>;</span><br><span class="line">    ret = TcpInit(argv[<span class="number">1</span>], argv[<span class="number">2</span>], &amp;socket_fd);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;TcpInit&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.创建epoll</span></span><br><span class="line">    <span class="keyword">int</span> epoll_fd = epoll_create(<span class="number">1</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把所有需要监听的描述符添加到epoll当中</span></span><br><span class="line">    EpollAddFd(epoll_fd, socket_fd);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process_num; ++i)&#123;</span><br><span class="line">        EpollAddFd(epoll_fd, pInfo[i].pipe_fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建epoll_event结构体数组，用于存储</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span>[2];</span></span><br><span class="line">    <span class="built_in">memset</span>(evs, <span class="number">0</span>, <span class="keyword">sizeof</span>(evs));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建new_fd用于接收客户端连接和数据</span></span><br><span class="line">    <span class="keyword">int</span> new_fd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示就绪的文件描述符数量</span></span><br><span class="line">    <span class="keyword">int</span> ready_fd_num = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得活跃的文件描述符数量，-1表示无条件等待</span></span><br><span class="line">        ready_fd_num = epoll_wait(epoll_fd, evs, <span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ready_fd_num; ++i)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//socket_fd就绪，服务器主进程接收连接，得到new_fd寻找空闲子进程</span></span><br><span class="line">            <span class="keyword">if</span>(evs[i].data.fd == socket_fd)&#123;</span><br><span class="line">                <span class="comment">//4.如果客户端连接服务器，使用accept接受这次连接请求，返回一个new_fd，并将new_fd交给空闲子进程</span></span><br><span class="line">                new_fd = accept(socket_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; process_num; ++j)&#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//如果该子进程不繁忙，传递文件描述符给子进程，修改子进程忙碌状态，退出循环</span></span><br><span class="line">                    <span class="keyword">if</span>(PROCESS_NO_BUSY == pInfo[j].busy_status)&#123;</span><br><span class="line">                        SendFd(pInfo[j].pipe_fd, new_fd);</span><br><span class="line">                        pInfo[j].busy_status = PROCESS_BUSY;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;process %d is busy.\n&quot;</span>, pInfo[j].pid);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//传给子进程的new_fd和子进程获取的new_fd指向同一片区域但数值不相同，因此关闭主进程的new_fd不影响子进程对new_fd的读写</span></span><br><span class="line">                close(new_fd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环遍历子进程的pipe_fd看是否有就绪的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; process_num; ++j)&#123;</span><br><span class="line">                <span class="comment">//5.epoll监听到pipe_fd可读，表示子进程工作完成，把子进程工作状态置为空闲</span></span><br><span class="line">                <span class="keyword">if</span>(evs[i].data.fd == pInfo[j].pipe_fd)&#123;</span><br><span class="line">                    <span class="comment">//用于接收子进程完成的信息</span></span><br><span class="line">                    <span class="keyword">char</span> buf[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                    ret = read(pInfo[j].pipe_fd, buf, <span class="number">2</span>);</span><br><span class="line">                    pInfo[j].busy_status = PROCESS_NO_BUSY;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;process %d is not busy.\n&quot;</span>, pInfo[j].pid);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="createprocessc创建子进程"><a class="markdownIt-Anchor" href="#createprocessc创建子进程"></a> CreateProcess.c：创建子进程</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreateProcess</span><span class="params">(pProcess_info_t pInfo,<span class="keyword">int</span> process_num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process_num; ++i)&#123;</span><br><span class="line">        <span class="comment">//创建一对相连的套接口，类似于全双工管道，只能在本机中使用</span></span><br><span class="line">        ret = socketpair(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>, fds);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;socketpair&quot;</span>);</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == pid)&#123;</span><br><span class="line">            close(fds[<span class="number">0</span>]);</span><br><span class="line">            ChildFunc(fds[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fds[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//记录子进程的相关信息</span></span><br><span class="line">        pInfo[i].pid = pid;</span><br><span class="line">        <span class="comment">//!!!!!!!!!!!!!!!!!!给错了pInfo[i].pipe_fd = fds[1];导致epoll_add出错了</span></span><br><span class="line">        pInfo[i].pipe_fd = fds[<span class="number">0</span>];</span><br><span class="line">        pInfo[i].busy_status = PROCESS_NO_BUSY;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="childfuncc子进程函数用于写对客户端的服务"><a class="markdownIt-Anchor" href="#childfuncc子进程函数用于写对客户端的服务"></a> ChildFunc.c：子进程函数，用于写对客户端的服务</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ChildFunc</span><span class="params">(<span class="keyword">int</span> pipe_fd)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用client_fd接收从主进程传来的new_fd</span></span><br><span class="line">    <span class="keyword">int</span> client_fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.调用RecvFd函数用于接收与客户端通信的client_fd</span></span><br><span class="line">        ret = RecvFd(pipe_fd, &amp;client_fd);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;RecvFd&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.传输文件给客户端，不需要报错，报错正常执行，不能因为客户端导致服务器崩溃</span></span><br><span class="line">        TransFile(client_fd);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.通知父进程服务完成</span></span><br><span class="line">        ret = write(pipe_fd, <span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;write&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.关闭client_fd</span></span><br><span class="line">        close(client_fd);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="recvfdc子进程接收主进程发送的与客户端通信的文件描述符"><a class="markdownIt-Anchor" href="#recvfdc子进程接收主进程发送的与客户端通信的文件描述符"></a> RecvFd.c：子进程接收主进程发送的与客户端通信的文件描述符</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RecvFd</span><span class="params">(<span class="keyword">int</span> pipe_fd, <span class="keyword">int</span> *new_fd)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建sendmsg可用的数据结构体msg，并初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建msg中的iovec结构体iov，并初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;iov, <span class="number">0</span>, <span class="keyword">sizeof</span>(iov));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//iovec必须要赋值，iov.iov_base存储的是一个地址</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    iov.iov_base = buf;</span><br><span class="line">    iov.iov_len = <span class="built_in">strlen</span>(buf);</span><br><span class="line"></span><br><span class="line">    msg.msg_iov = &amp;iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//因为cmsg中有个柔性数组，所以只能申请堆空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cmsg</span> =</span> (struct cmsghdr*)<span class="built_in">calloc</span>(<span class="number">1</span>, len);</span><br><span class="line">    cmsg-&gt;cmsg_len = len;</span><br><span class="line">    cmsg-&gt;cmsg_level = SOL_SOCKET;</span><br><span class="line">    cmsg-&gt;cmsg_type = SCM_RIGHTS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//msg的附属数据结构体指向cmsg</span></span><br><span class="line">    msg.msg_control = cmsg;</span><br><span class="line">    msg.msg_controllen = len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用pipe_fd向子进程接收msg</span></span><br><span class="line">    <span class="comment">//用ssize_t recvmsg(int sockfd, const struct msghdr *msg, int flags)可以发送文件描述符</span></span><br><span class="line">    recvmsg(pipe_fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//柔性数组的数据用CMSG_DATA()接收，要进行类型转换</span></span><br><span class="line">    *new_fd = *(<span class="keyword">int</span>*)CMSG_DATA(cmsg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="sendfdc主进程发送与客户端通信的文件描述符给子进程"><a class="markdownIt-Anchor" href="#sendfdc主进程发送与客户端通信的文件描述符给子进程"></a> SendFd.c：主进程发送与客户端通信的文件描述符给子进程</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SendFd</span><span class="params">(<span class="keyword">int</span> pipe_fd, <span class="keyword">int</span> new_fd)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建sendmsg可用的数据结构体msg，并初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建msg中的iovec结构体iov，并初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;iov, <span class="number">0</span>, <span class="keyword">sizeof</span>(iov));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//iovec必须要赋值，iov.iov_base存储的是一个地址</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    iov.iov_base = buf;</span><br><span class="line">    iov.iov_len = <span class="built_in">strlen</span>(buf);</span><br><span class="line"></span><br><span class="line">    msg.msg_iov = &amp;iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//因为cmsg中有个柔性数组，所以只能申请堆空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cmsg</span> =</span> (struct cmsghdr*)<span class="built_in">calloc</span>(<span class="number">1</span>, len);</span><br><span class="line">    cmsg-&gt;cmsg_len = len;</span><br><span class="line">    cmsg-&gt;cmsg_level = SOL_SOCKET;</span><br><span class="line">    cmsg-&gt;cmsg_type = SCM_RIGHTS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//柔性数组的数据用CMSG_DATA()接收，要进行类型转换</span></span><br><span class="line">    *(<span class="keyword">int</span>*)CMSG_DATA(cmsg) = new_fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//msg的附属数据结构体指向cmsg</span></span><br><span class="line">    msg.msg_control = cmsg;</span><br><span class="line">    msg.msg_controllen = len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用pipe_fd向子进程发送msg</span></span><br><span class="line">    <span class="comment">//用ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags)可以发送文件描述符</span></span><br><span class="line">    sendmsg(pipe_fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="transfilec文件传输函数"><a class="markdownIt-Anchor" href="#transfilec文件传输函数"></a> TransFile.c：文件传输函数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接收一次SIGPIPE信号，防止信号中断程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigfunc</span><span class="params">(<span class="keyword">int</span> signum)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGPIPE is coimg&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TransFile</span><span class="params">(<span class="keyword">int</span> client_fd)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    signal(SIGPIPE, sigfunc);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;1.pdf&quot;</span>, O_RDONLY);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;open&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前文件的状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">fileInfo</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;fileInfo, <span class="number">0</span>, <span class="keyword">sizeof</span>(fileInfo));</span><br><span class="line">    ret = fstat(fd, &amp;fileInfo);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;fstat&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建传输数据结构体</span></span><br><span class="line">    <span class="keyword">train_t</span> train;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;train, <span class="number">0</span>, <span class="keyword">sizeof</span>(train));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送文件名</span></span><br><span class="line">    train.data_len = <span class="built_in">strlen</span>(<span class="string">&quot;1.pdf&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(train.data_buf, <span class="string">&quot;1.pdf&quot;</span>);</span><br><span class="line">    ret = send(client_fd, &amp;train, <span class="number">4</span> + train.data_len, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;send&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;train, <span class="number">0</span>, <span class="keyword">sizeof</span>(train));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送文件大小</span></span><br><span class="line">    train.data_len = <span class="keyword">sizeof</span>(fileInfo.st_size);</span><br><span class="line">    <span class="built_in">memcpy</span>(train.data_buf, &amp;fileInfo.st_size, <span class="keyword">sizeof</span>(<span class="keyword">off_t</span>));</span><br><span class="line">    send(client_fd, &amp;train, <span class="number">4</span> + train.data_len, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fileSize = %ld\n&quot;</span>, fileInfo.st_size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//----------------------------------零拷贝修改区----------------------------------//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;train, <span class="number">0</span>, <span class="keyword">sizeof</span>(train));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环文件发送数据</span></span><br><span class="line">        train.data_len = read(fd, train.data_buf, <span class="keyword">sizeof</span>(train.data_buf));</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == train.data_len)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送错误则退出发送</span></span><br><span class="line">        ret = send(client_fd, &amp;train, train.data_len + <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;TransFile_send&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//发送数据为0时退出循环</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == train.data_len)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//----------------------------------零拷贝修改区----------------------------------//</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="tcpinitc创建主进程的tcp监听套接字"><a class="markdownIt-Anchor" href="#tcpinitc创建主进程的tcp监听套接字"></a> TcpInit.c：创建主进程的TCP监听套接字</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TcpInit</span><span class="params">(<span class="keyword">char</span> *ip, <span class="keyword">char</span>*port, <span class="keyword">int</span> *socket_fd)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="comment">/*分别设置协议、IP地址和端口号*/</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line">    addr.sin_port = htons(atoi(port));</span><br><span class="line"></span><br><span class="line">    *socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(*socket_fd, <span class="number">-1</span>, <span class="string">&quot;socket&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置地址可重用</span></span><br><span class="line">    <span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">    ret = setsockopt(*socket_fd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置缓冲区大小</span></span><br><span class="line">    <span class="keyword">int</span> buf = <span class="number">65536</span>;</span><br><span class="line">    ret = setsockopt(*socket_fd, SOL_SOCKET, SO_SNDBUF, &amp;buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绑定ip地址和端口号</span></span><br><span class="line">    ret = bind(*socket_fd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;bind&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听描述符，最大连接数设置为10</span></span><br><span class="line">    ret = listen(*socket_fd, <span class="number">10</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;ret&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="epolladdfdc将文件描述符添加进epoll"><a class="markdownIt-Anchor" href="#epolladdfdc将文件描述符添加进epoll"></a> EpollAddFd.c：将文件描述符添加进epoll</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EpollAddFd</span><span class="params">(<span class="keyword">int</span> epoll_fd, <span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;events, <span class="number">0</span>, <span class="keyword">sizeof</span>(events));</span><br><span class="line">    events.events = EPOLLIN;</span><br><span class="line">    events.data.fd = fd;</span><br><span class="line">    <span class="comment">//将fd添加进epoll</span></span><br><span class="line">    <span class="keyword">int</span> ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;events);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="客户端设计"><a class="markdownIt-Anchor" href="#客户端设计"></a> 客户端设计</h1>
<h2 id="程序设计-2"><a class="markdownIt-Anchor" href="#程序设计-2"></a> 程序设计</h2>
<h3 id="clientc客户端主程序"><a class="markdownIt-Anchor" href="#clientc客户端主程序"></a> client.c：客户端主程序</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存服务器端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套接字文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(socket_fd, <span class="number">-1</span>, <span class="string">&quot;socket&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置接收缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> recv_buf = <span class="number">65536</span>;</span><br><span class="line">    ret = setsockopt(socket_fd, SOL_SOCKET, SO_RCVBUF, &amp;recv_buf, <span class="keyword">sizeof</span>(recv_buf));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    ret = connect(socket_fd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;connect&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> data_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">off_t</span> file_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.先接收文件名长度</span></span><br><span class="line">    ret = recv(socket_fd, &amp;data_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;recv_name_len&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.根据文件名长度接收文件名</span></span><br><span class="line">    ret = recv(socket_fd, buf, data_len, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;recv_name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.接收文件大小</span></span><br><span class="line">    ret = recv(socket_fd, &amp;data_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">    ret = recv(socket_fd, &amp;file_len, data_len, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.根据文件名打开文件</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(buf, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    ERROR_CHECK(fd, <span class="number">-1</span>, <span class="string">&quot;open&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------------------------零拷贝修改区----------------------------------//</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置接收文件的大小</span></span><br><span class="line">    <span class="keyword">off_t</span> file_len_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计次数打印进度条</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//!!!!!!!!!!!!!!!!!!!!!!!!清空缓冲区!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.接收文件长度</span></span><br><span class="line">        recv(socket_fd, &amp;data_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == data_len)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.接收文件数据</span></span><br><span class="line">        ret = RecvFile(socket_fd, buf, data_len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.统计现有文件大小，打印进度条</span></span><br><span class="line">        file_len_num += ret;</span><br><span class="line">        cnt = PrintProgressRate(file_len, file_len_num, cnt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.写入文件</span></span><br><span class="line">        write(fd, buf, data_len);</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------------------------零拷贝修改区----------------------------------//</span></span><br><span class="line"></span><br><span class="line">    close(socket_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="recvfilec封装一个接收指定大小数据的函数"><a class="markdownIt-Anchor" href="#recvfilec封装一个接收指定大小数据的函数"></a> RecvFile.c：封装一个接收指定大小数据的函数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RecvFile</span><span class="params">(<span class="keyword">int</span> socket_fd, <span class="keyword">void</span> *buf, <span class="keyword">int</span> data_len)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> get_file_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(get_file_len &lt; data_len)&#123;</span><br><span class="line">        <span class="comment">//动态接收数据，等到接收数据达到想要接受的长度时退出</span></span><br><span class="line">        ret = recv(socket_fd, (<span class="keyword">char</span> *)buf + get_file_len, data_len - get_file_len, <span class="number">0</span>);</span><br><span class="line">        get_file_len += ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> get_file_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="printprogressratec打印进度条程序"><a class="markdownIt-Anchor" href="#printprogressratec打印进度条程序"></a> PrintProgressRate.c：打印进度条程序</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PrintProgressRate</span><span class="params">(<span class="keyword">off_t</span> final_num, <span class="keyword">off_t</span> now_num, <span class="keyword">int</span> cnt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> all = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">2</span>] = <span class="string">&quot;%&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(final_num == now_num)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; all; ++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;█&quot;</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;100.00%s\n&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">100</span> == ++cnt)&#123;</span><br><span class="line">        <span class="keyword">double</span> bar = (<span class="keyword">double</span>)now_num / final_num * <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> space_num = all - (<span class="keyword">int</span>)bar / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; all - space_num; ++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;█&quot;</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; space_num - <span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5.2lf%s\r&quot;</span>, bar, str);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="遇到的问题"><a class="markdownIt-Anchor" href="#遇到的问题"></a> 遇到的问题</h1>
<ol>
<li>发送文件名和文件数据粘在一块。
<ul>
<li>原因：TCP粘包问题，多次发送的数据被一次接收，数据之间没有分界线，所有数据都粘在一起。</li>
<li>解决方法：人为去设计一个结构体，规定数据与数据之间的分界线(私有协议)。</li>
</ul>
</li>
<li>客户端接收文件时，接收到的文件和服务器上的文件大小内容不一样，但是传输过程没有问题。
<ul>
<li>原因：循环接收时没有清空接收缓冲区，导致错误接收。</li>
<li>解决办法：清空接收缓冲区。</li>
</ul>
</li>
<li>客户端报栈损坏、段错误。
<ul>
<li>原因：由于发送速度不匹配，造成客户端接收数据时读取数据时不一定时正确的顺序。读取认为规定的结构体时发生错误的读取，读取到错误的数据长度，导致客户端访问到了不能访问的内存空间因此程序崩溃。</li>
<li>解决方案：①设置recv的标志位为MSG_WAITALL；②封装自己的recv函数规定接收数据大小；③写一个ERROR_CHECK()宏检测，检测到错误即使返回。</li>
</ul>
</li>
<li>客户端主动退出，服务器崩溃。
<ul>
<li>原因：服务器子程序发送失败时，用了一个ERROR_CHECK()宏检测，导致子进程异常退出，父进程与子进程间通信的文件描述符成为一个无效的文件描述符，子进程会循环发送SIGPIPE信号。</li>
<li>解决办法：传输文件处写一个signal函数捕捉SIGPIPE信号。子进程传输失败时不予理会，当作服务完成，正常向后执行（<strong>不能因为客户端的问题引起服务器崩溃</strong>）。</li>
</ul>
</li>
<li>小错误：<strong>创建并存储子进程信息时(CreateProcess.c)，发生关闭该管道又存储该管道，epoll_add的时候出现报错。</strong></li>
</ol>
<h1 id="后续可以做的改进"><a class="markdownIt-Anchor" href="#后续可以做的改进"></a> 后续可以做的改进</h1>
<ol>
<li>
<p>零拷贝传输：先前传输文件时循环调用send系统调用，发生用户态到内核态再由内核态到用户态的拷贝，使用零拷贝技术，减少内核态和用户台之间的拷贝次数，从而加快服务器传输速率。</p>
<p>客户端使用零拷贝技术接收（修改client.c的修改区使用mmap）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">beg</span>, <span class="title">end</span>;</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp;beg, <span class="number">0</span>, <span class="keyword">sizeof</span>(beg));</span><br><span class="line">   <span class="built_in">memset</span>(&amp;end, <span class="number">0</span>, <span class="keyword">sizeof</span>(end));</span><br><span class="line">   </span><br><span class="line">   gettimeofday(&amp;beg, <span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line">   ftruncate(fd, file_len);</span><br><span class="line">   <span class="comment">//用mmap进行地址映射</span></span><br><span class="line">   <span class="keyword">char</span> *<span class="built_in">map</span> = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, file_len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">   ERROR_CHECK(<span class="built_in">map</span>, (<span class="keyword">char</span> *)<span class="number">-1</span>, <span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   recv(socket_fd, <span class="built_in">map</span>, file_len, MSG_WAITALL);</span><br><span class="line">   </span><br><span class="line">   munmap(<span class="built_in">map</span>, file_len);</span><br><span class="line">   </span><br><span class="line">   gettimeofday(&amp;end, <span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line"><span class="comment">//可以统计传输效率</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;total time = %lf\n&quot;</span>, (end.tv_sec - beg.tv_sec) + ((end.tv_usec - beg.tv_usec) / <span class="number">1000.0</span>) / <span class="number">1000.0</span>);</span><br></pre></td></tr></table></figure>
<p>服务器的三种零拷贝技术（修该TransFile.c的修改区）：</p>
<ul>
<li>
<p>mmap文件映射：传输240M文件0.9s左右</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.用mmap进行地址映射</span></span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">map</span> = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, fileInfo.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>); </span><br><span class="line">ERROR_CHECK(<span class="built_in">map</span>, (<span class="keyword">void</span> *)<span class="number">-1</span>, <span class="string">&quot;mmap&quot;</span>); </span><br><span class="line"><span class="comment">//发送整个map </span></span><br><span class="line">send(client_fd, <span class="built_in">map</span>, fileInfo.st_size, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//解映射</span></span><br><span class="line">munmap(<span class="built_in">map</span>, fileInfo.st_size);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>sendfile函数：传输240M文件0.7s左右</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ssize_t sendfile(int out_fd, int fd, off_t *offset, size_t count)</span></span><br><span class="line"><span class="comment">成功返回发送的字节数，失败返回-1</span></span><br><span class="line"><span class="comment">参数1：往哪写入数据</span></span><br><span class="line"><span class="comment">参数2：从哪读取数据</span></span><br><span class="line"><span class="comment">参数3：文件偏移量</span></span><br><span class="line"><span class="comment">参数4：传输数据的长度</span></span><br><span class="line"><span class="comment">sendfile只能用于发送端发送数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//2.用sendfile发送文件</span></span><br><span class="line">ret = sendfile(client_fd, fd, <span class="number">0</span>, fileInfo.st_size);</span><br><span class="line">ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;sendfile&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>splice函数：传输240M文件，发送大小设置128时需要2.2s左右，发送大小设置为65536时需要0.7s左右</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需要打开一个宏开关：#define _GNU_SOURCE</span></span><br><span class="line"><span class="comment">需要一根管道，用于发送和接收数据</span></span><br><span class="line"><span class="comment">ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags)</span></span><br><span class="line"><span class="comment">成功返回发送的字节数，失败返回-1</span></span><br><span class="line"><span class="comment">参数1：从哪取数据</span></span><br><span class="line"><span class="comment">参数2：偏移量</span></span><br><span class="line"><span class="comment">参数3：往哪写数据</span></span><br><span class="line"><span class="comment">参数4：偏移量</span></span><br><span class="line"><span class="comment">参数5：单次写入数据长度（最多65536）---&gt;可以通过这个的大小控制传输速度</span></span><br><span class="line"><span class="comment">参数6：标识位，一般填0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//3.用户splice传输文件，要利用一根管道，用文件描述符往里写，客户端通信文件描述符从里面取</span></span><br><span class="line"><span class="keyword">long</span> send_size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fds[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">pipe(fds);</span><br><span class="line"><span class="keyword">while</span>(send_size &lt; fileInfo.st_size)&#123;</span><br><span class="line">    ret = splice(fd, <span class="number">0</span>, fds[<span class="number">1</span>], <span class="number">0</span>, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">    ret = splice(fds[<span class="number">0</span>], <span class="number">0</span>, client_fd, <span class="number">0</span>, ret, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;splice&quot;</span>);</span><br><span class="line">    send_size += ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>四种发送文件对比：</p>
<ul>
<li>文件速度：sendfile &gt; mmap &gt; send，splice可以自行控制速度。</li>
<li>限制：
<ol>
<li>sendfile和mmap有文件大小限制，最大可以传输2G的大文件。</li>
<li>零拷贝接口的可移植性不是很好。</li>
<li>数据传输的瓶颈始终在于<strong>网络状态</strong>。</li>
</ol>
</li>
</ul>
</li>
<li>
<p>进程池的退出。</p>
<ul>
<li>
<p>暴力退出：父进程收到退出信号后，依次杀死子进程。</p>
<p>服务器main.c添加一个全局变量out标识符，一个信号捕捉函数和一个信号处理函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局out标识位</span></span><br><span class="line"><span class="keyword">short</span> out = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main_sigfunc</span><span class="params">(<span class="keyword">int</span> signum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">10</span> == signum)&#123;</span><br><span class="line">        out = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号捕捉函数添加在创建子进程后面，以防子进程继承主函数的信号捕捉函数</span></span><br><span class="line">signal(<span class="number">10</span>, main_sigfunc);</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴力退出子进程，加在主函数while(1)中</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> == out)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process_num; ++i)&#123;</span><br><span class="line">        kill(pInfo[i].pid, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main out\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器ChildFunc.c添加一个信号捕捉函数和处理函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">child_sigfunc</span><span class="params">(<span class="keyword">int</span> signum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">10</span> == signum)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child out\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号捕捉函数</span></span><br><span class="line">signal(<span class="number">10</span>, child_sigfunc);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>温柔退出：父进程收到退出信号后，给子进程发送退出标记，如果子进程正在忙碌，忙完后自行退出。</p>
<p>main.c修改：添加一个全局管道，用于在程序捕捉到10号信号时，通过异步拉起同步的方式，通过管道发送退出信息给自己，再由自己通知子程序退出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> out_pipe[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main_sigfunc</span><span class="params">(<span class="keyword">int</span> signum)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main get signum = %d\n&quot;</span>, signum);</span><br><span class="line">    <span class="comment">//异步拉起同步的方式</span></span><br><span class="line">    write(out_pipe[<span class="number">1</span>], &amp;signum, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//......此处省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建用于管道</span></span><br><span class="line">    pipe(out_pipe);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加管道读端进epoll</span></span><br><span class="line">    EpollAddFd(epoll_fd, out_pipe[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//......此处省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//获得活跃的文件描述符数量，-1表示无条件等待</span></span><br><span class="line">        ready_fd_num = epoll_wait(epoll_fd, evs, <span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ready_fd_num; ++i)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//服务器收到信号处理函数发给自己的退出信息，给每个子进程发送退出信息</span></span><br><span class="line">            <span class="keyword">if</span>(evs[i].data.fd == out_pipe[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; process_num; ++j)&#123;</span><br><span class="line">                    SendFd(pInfo[j].pipe_fd, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; process_num; ++j)&#123;</span><br><span class="line">                    wait(<span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;main out\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//socket_fd就绪，服务器主进程接收连接，得到new_fd寻找空闲子进程</span></span><br><span class="line">            <span class="keyword">if</span>(evs[i].data.fd == socket_fd)&#123;</span><br><span class="line">                <span class="comment">//4.如果客户端连接服务器，使用accept接受这次连接请求，返回一个new_fd，并将new_fd交给空闲子进程</span></span><br><span class="line">                new_fd = accept(socket_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; process_num; ++j)&#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//如果该子进程不繁忙，传递文件描述符给子进程，修改子进程忙碌状态，退出循环</span></span><br><span class="line">                    <span class="keyword">if</span>(PROCESS_NO_BUSY == pInfo[j].busy_status)&#123;</span><br><span class="line">                        SendFd(pInfo[j].pipe_fd, new_fd, <span class="number">0</span>);</span><br><span class="line">                        pInfo[j].busy_status = PROCESS_BUSY;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;process %d is busy.\n&quot;</span>, pInfo[j].pid);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//传给子进程的new_fd和子进程获取的new_fd指向同一片区域但数值不相同，因此关闭主进程的new_fd不影响子进程对new_fd的读写</span></span><br><span class="line">                close(new_fd);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//......此处省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SendFd.c修改：添加一个out_flag标识位，用于向子进程发送退出消息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SendFd</span><span class="params">(<span class="keyword">int</span> pipe_fd, <span class="keyword">int</span> new_fd, <span class="keyword">int</span> out_flag)</span></span>&#123;</span><br><span class="line">    <span class="comment">//......此处省略</span></span><br><span class="line">    iov.iov_base = &amp;out_flag;</span><br><span class="line">    iov.iov_len = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//......此处省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RecvFd.c修改：添加一个out_flag标识位，用于接收子进程退出消息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RecvFd</span><span class="params">(<span class="keyword">int</span> pipe_fd, <span class="keyword">int</span> *new_fd, <span class="keyword">int</span> *out_flag)</span></span>&#123;</span><br><span class="line">    <span class="comment">//......此处省略</span></span><br><span class="line">    iov.iov_base = out_flag;</span><br><span class="line">    iov.iov_len = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//......此处省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ChildFunc.c修改：添加一个out_flag标识位，用于存储RecvFd函数收到的out_flag标识位，判断是否要退出进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ChildFunc</span><span class="params">(<span class="keyword">int</span> pipe_fd)</span></span>&#123;</span><br><span class="line">    <span class="comment">//......此处省略</span></span><br><span class="line">    <span class="keyword">int</span> out_flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//......此处省略</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.调用RecvFd函数用于接收与客户端通信的client_fd，阻塞性函數</span></span><br><span class="line">        ret = RecvFd(pipe_fd, &amp;client_fd, &amp;out_flag);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;RecvFd&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == out_flag)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child out\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//......此处省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用指令整理</title>
    <url>/2021/11/09/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="常用指令"><a class="markdownIt-Anchor" href="#常用指令"></a> 常用指令</h1>
<span id="more"></span>
<ol>
<li>
<p>查找含<code>xxx</code>信息的进程：<code>ps -elf|grep xxx</code></p>
</li>
<li>
<p>查看当前使用系统的用户：<code>who</code></p>
</li>
<li>
<p>查看系统的发行版本：<code>cat /etc/issue</code></p>
</li>
<li>
<p>查看内核版本：<code>uname -a</code></p>
</li>
<li>
<p>查看当前工作目录：<code>pwd</code></p>
</li>
<li>
<p><code>man</code>命令：</p>
<ol>
<li><code>man xxx</code>：显示xxx的使用文档</li>
<li><code>man -k xxx</code>：用xxx搜索整个手册的匹配部分</li>
<li><code>man -f xxx</code>：用xxx搜索整个手册的完全匹配部分</li>
</ol>
</li>
<li>
<p><code>chmod</code>命令：修改文件权限</p>
<table>
<thead>
<tr>
<th>用户身份</th>
<th>行为</th>
<th>权限</th>
</tr>
</thead>
<tbody>
<tr>
<td>u：拥有者</td>
<td>+：添加</td>
<td>r：读权限</td>
</tr>
<tr>
<td>g：拥有者所在组</td>
<td>-：删除</td>
<td>w：写权限</td>
</tr>
<tr>
<td>o：其他用户</td>
<td>=：赋值</td>
<td>x：执行权限</td>
</tr>
<tr>
<td>a：所有用户</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p><code>find</code>命令格式：</p>
<ol>
<li>
<p><code>find [起始目录] [查找条件]</code></p>
<table>
<thead>
<tr>
<th>查找条件</th>
<th>后续参数或者功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>-name</td>
<td>[文件名]（需要完全匹配）（使用wildcard通配符可实现模糊查找，*取代任意字符串，?取代任意字符，[集合]取代集合内的内容）</td>
</tr>
<tr>
<td>-user</td>
<td>[用户名]</td>
</tr>
<tr>
<td>-group</td>
<td>[组名]</td>
</tr>
<tr>
<td>-uid</td>
<td>[用户id]</td>
</tr>
<tr>
<td>-gid</td>
<td>[组id]</td>
</tr>
<tr>
<td>-perm</td>
<td>[权限]（数字表表示）</td>
</tr>
<tr>
<td>-size</td>
<td>+/- [n 单位]（默认为一个块512bytes）</td>
</tr>
<tr>
<td>-type</td>
<td>[类型]</td>
</tr>
<tr>
<td>-empty</td>
<td>（查找空目录）</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>按时间查找：<code>find [参数] [+/-n](距离现在的时间间隔)</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>分钟</th>
<th>天</th>
</tr>
</thead>
<tbody>
<tr>
<td>a(访问时间)</td>
<td>-amin</td>
<td>-atime</td>
</tr>
<tr>
<td>c(状态修改时间)</td>
<td>-cmin</td>
<td>-ctime</td>
</tr>
<tr>
<td>m(内容修改时间)</td>
<td>-mmin</td>
<td>-mtime</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>查找的与或非：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>与</td>
</tr>
<tr>
<td>-o</td>
<td>或</td>
</tr>
<tr>
<td>!</td>
<td>非</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><code>-exec参数</code>：根据<code>find</code>的查找结果进行后续操作</p>
<p>例：<code>find . -name &quot;file&quot; -exec ls -l &#123;(find . -name &quot;file&quot;)的查询结果&#125; \;</code></p>
</li>
</ol>
</li>
<li>
<p>磁盘命令：</p>
<ol>
<li><code>df -h</code>：查看整个磁盘的文件系统</li>
<li><code>du -d [n]</code>：查看当前目录下深度为的所有目录</li>
</ol>
</li>
<li>
<p>文件查看命令：<code>cat [-b/-n]（结果加行号，空白行（不加/加））</code></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++特性之继承</title>
    <url>/2021/11/09/C++%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h1>
<ol>
<li>定义：从既有类（父类、基类）生成新类（子类、派生类）的过程。</li>
</ol>
<span id="more"></span>
<ol start="2">
<li>格式：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类</span></span><br><span class="line"><span class="class">:</span> <span class="keyword">public</span>/<span class="keyword">protected</span>/<span class="keyword">private</span> 基类&#123;</span><br><span class="line">    <span class="comment">//默认的继承方式是私有继承</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>继承时派生类生成的三个步骤：吸收、改造、添加。</p>
</li>
<li>
<p>继承的局限性：以下这些基类特征不能被继承</p>
<p>构造函数、析构函数、用户重载的operator new/delete运算符、用户重载的operator =运算符、友元关系。</p>
</li>
<li>
<p>继承方式对派生类访问权限的影响</p>
<table>
<thead>
<tr>
<th style="text-align:center">继承方式</th>
<th style="text-align:center">基类成员访问权限</th>
<th style="text-align:center">在派生类中访问权限</th>
<th style="text-align:center">派生类对象访问</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">public<br>protected<br>private</td>
<td style="text-align:center">public<br>protected<br>不可直接访问</td>
<td style="text-align:center">可直接访问<br>不可直接访问<br>不可直接访问</td>
</tr>
<tr>
<td style="text-align:center">protected</td>
<td style="text-align:center">public<br>protected<br>private</td>
<td style="text-align:center">protected<br>protected<br>不可直接访问</td>
<td style="text-align:center">不可直接访问</td>
</tr>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">public<br>protected<br>private</td>
<td style="text-align:center">private<br>private<br>不可直接访问</td>
<td style="text-align:center">不可直接访问</td>
</tr>
</tbody>
</table>
<p>不管以什么方式继承，派生类内部都不能访问基类的私有成员，其他都可以访问。<strong>派生类对象</strong>除了公有继承基类中的公有成员可以访问外，其他的一律不能访问。</p>
</li>
<li>
<p>派生类对象构造函数的一般格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">派生类(参数列表) ： 基类构造函数(参数列表)&#123;</span><br><span class="line">   <span class="comment">//函数体 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>派生类对象的销毁：派生类执行析构函数时，基类的析构函数会被自动调用。执行顺序是如下</p>
<ol>
<li>先调用派生类的析构函数</li>
<li>在调用派生类中成员对象的析构函数</li>
<li>最后调用普通基类的析构函数</li>
</ol>
</li>
<li>
<p>多基派生（继承）：派生类继承多个基类，格式如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类</span></span><br><span class="line"><span class="class">:</span> <span class="keyword">public</span>/<span class="keyword">protected</span>/<span class="keyword">private</span> 基类<span class="number">1</span></span><br><span class="line">, ...</span><br><span class="line">, <span class="keyword">public</span>/<span class="keyword">protected</span>/<span class="keyword">private</span> 基类N&#123; </span><br><span class="line">    <span class="comment">//派生类体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>多基继承的二义性：使用多基继承过程中，会产生两种二义性。</p>
<ol>
<li>
<p>成员名冲突的二义性：当多个基类中出现同名函数时，发生成员名冲突二义性。</p>
<p>解决方法：在调用时，使用作用于限定符调用函数。</p>
</li>
<li>
<p>菱形继承的二义性：派生的多个基类在继承路径上有一个共同基类，如下图<img src="/images/菱形继承.png" alt="img 菱形继承"></p>
<p>​解决方案：使用虚拟继承。</p>
</li>
</ol>
</li>
<li>
<p>基类与派生类之间的转换：</p>
<ol>
<li>派生类对象可以赋值给基类对象</li>
<li>基类的引用可以绑定到派生类对象</li>
<li>声明基类的指针可以指向派生类对象</li>
<li>向上转型：从派生类向基类进行转换，都是支持的。</li>
<li>向下转型：从基类向派生类进行转换，分为安全和不安全的两类。</li>
</ol>
</li>
<li>
<p>派生类对象之间的复制控制：基类的拷贝构造函数和operator=运算符函数不能被派生类继承，因此在执行派生类对象间的复制操作时，需要注意以下情况：</p>
<ol>
<li>如果用户定义了基类的拷贝构造函数，而没有定义派生类的拷贝构造函数，那么在用一个派生类对<br>
象初始化新的派生类对象时，两对象间的派生类部分执行缺省的行为，而两对象间的基类部分执行<br>
用户定义的基类拷贝构造函数。</li>
<li>如果用户重载了基类的赋值运算符函数，而没有重载派生类的赋值运算符函数，那么在用一个派生<br>
类对象给另一个已经存在的派生类对象赋值时，两对象间的派生类部分执行缺省的赋值行为，而两<br>
对象间的基类部分执行用户定义的重载赋值函数。</li>
<li>如果用户定义了派生类的拷贝构造函数或者重载了派生类的对象赋值运算符=，则在用已有派生类<br>
对象初始化新的派生类对象时，或者在派生类对象间赋值时，将会执行用户定义的派生类的拷贝构<br>
造函数或者重载赋值函数，而不会再自动调用基类的拷贝构造函数和基类的重载对象赋值运算符，<br>
这时，通常需要用户在派生类的拷贝构造函数或者派生类的赋值函数中显式调用基类的拷贝构造或<br>
赋值运算符函数。</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信方式(1)-管道</title>
    <url>/2021/07/13/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F(1)-%E7%AE%A1%E9%81%93/</url>
    <content><![CDATA[<h1 id="管道"><a class="markdownIt-Anchor" href="#管道"></a> 管道</h1>
<p>定义：管道是一个进程连接数据流到另一个进程的通道，它通常是用作把一个进程的输出通过管道连接到另一个进程的输入。</p>
<span id="more"></span>
<h1 id="无名管道"><a class="markdownIt-Anchor" href="#无名管道"></a> 无名管道</h1>
<ol>
<li>创建：使用<code>int pipe(int pipe_fd[2])</code>函数创建。
<ul>
<li>返回值：成功返回0，失败返回1。</li>
<li>参数是一个数组，保存的是管道两端的文件描述符，pipe_fd[1]是写端，pipe_fd[0]是读端。</li>
</ul>
</li>
<li>特点：
<ul>
<li>无名管道只能在有亲缘关系的进程间进行通信；例如父子，兄弟进程。</li>
<li>无名管道是半双工的，想要实现全双工需要建立两条无名管道。</li>
<li>依赖于文件系统，生命周期随着进程的结束而结束。</li>
<li>管道是基于字节流来通信的，数据与数据之间没有边界，多次写管道的话数据是粘在一起的。</li>
<li>管道关闭读端，然后写管道的话，程序会收到系统发送的SIGPIPE信号，中止程序，进程的退出码是141。shell中输入<code>echo $?</code>可以查看上次程序退出码，退出码大于128的进程都是呗信号打断的。</li>
<li>管道关闭写端，用read读取管道，read变成非阻塞状态，并返回0；</li>
</ul>
</li>
</ol>
<h1 id="有名管道"><a class="markdownIt-Anchor" href="#有名管道"></a> 有名管道</h1>
<ol>
<li>
<p>创建：使用<code>int mkfifo(const char *pathname, mod_t mode)</code>函数创建。</p>
<ul>
<li>返回值：成功返回0，失败返回-1。</li>
<li>参数1：管道名。</li>
<li>参数2：有名管道权限。</li>
</ul>
</li>
<li>
<p>特点：</p>
<ul>
<li>在没有亲缘关系之间的进程间进行通信。</li>
<li>是一种特殊类型的文件，不会随着进程的结束而消失。</li>
</ul>
</li>
<li>
<p>删除有名管道：使用<code>int unlink(const char *pathname)</code>函数删除。</p>
<ul>
<li>
<p>返回值：成功则返回0, 失败返回-1。</p>
</li>
<li>
<p>参数：管道/文件名。</p>
</li>
<li>
<p>不仅可以删除有名管道文件，还可以删除普通的文件。</p>
</li>
<li>
<p>实质是删除文件的连接数，当该文件的连接数为0时，才真正的删除管道/文件。</p>
</li>
</ul>
</li>
</ol>
<h2 id="标准流管道用的少"><a class="markdownIt-Anchor" href="#标准流管道用的少"></a> 标准流管道（用的少）</h2>
<ol>
<li>
<p>创建：使用<code>FILE *popen(const char *cmd, const char *type)</code>函数创建。</p>
<ul>
<li>
<p>返回值：成功返回标准I/O流，失败返回NULL。</p>
</li>
<li>
<p>参数1：启动另外一个进程。</p>
</li>
<li>
<p>参数2：打开的方式。</p>
</li>
</ul>
</li>
<li>
<p>特点：popen其实就是对管道的操作进行封装。</p>
<ol>
<li>创建一条管道。</li>
<li>fork一个子进程。</li>
<li>在父进程中关闭不需要使用的文件描述符。</li>
<li>执行exec函数族的调用。</li>
<li>执行函数中所指定的命令。</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信方式(2)-共享内存</title>
    <url>/2021/07/23/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F(2)-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="共享内存"><a class="markdownIt-Anchor" href="#共享内存"></a> 共享内存</h1>
<p>定义：共享内存是一段特殊的内存区域，可以被多个进程共享，进程想要使用该空间，需要将共享内存映射到本程序的地址空间中，就可以实现进程间的数据交互。</p>
<span id="more"></span>
<ol>
<li>共享内存创建函数<code>int shmget(key_t key, size_t size, int shmflg)</code>
<ul>
<li>返回值：成功返回共享内存的id，失败返回-1</li>
<li>参数1：一个整型值，可以用<code>key_t ftok(const char *pathname, int proj_id)</code>生成</li>
<li>参数2：共享内存的大小（单位：字节）</li>
<li>参数3：标志位，一般为<code>IPC_CREAT | 0666</code>意思是创建共享内存，权限为0666</li>
</ul>
</li>
<li>查看创建的共享内存
<ul>
<li><code>ipcs</code></li>
</ul>
</li>
<li>删除共享内存
<ul>
<li><code>ipcrm -m &lt;共享内存id&gt;</code></li>
<li><code>ipcrm -M &lt;键值(key)&gt;</code></li>
</ul>
</li>
<li>共享内存映射函数<code>void *shmat(int shmid, const void *shmaddr, int shmflg)</code>
<ul>
<li>返回值：成功返回一个指针，指向所创建的共享内存，失败返回(void *)-1</li>
<li>参数1：共享内存的ID</li>
<li>参数2：共享内存的地址，通常填NULL表示让内核来分配空间</li>
<li>参数3：标志位，一般填0</li>
</ul>
</li>
<li>共享内存解除映射函数<code>int shmdt(const void *shmaddr)</code>
<ul>
<li>返回值：成功返回0，失败返回-1</li>
<li>参数：shmat函数返回的指针</li>
</ul>
</li>
<li>共享内存操作函数<code>int shmctl(int shmid, ind cmd, struct shmid_ds *buf)</code>
<ul>
<li>返回值：成功返回0，失败返回-1</li>
<li>参数1：共享内存的id</li>
<li>参数2：要执行的操作
<ul>
<li>IPC_SATA：获取共享内存的状态信息，并存入buf中</li>
<li>IPC_SET：改变共享内存的状态信息，如uid，gid，mode</li>
<li>IPC_RMID：删除共享内存，不需要填参数3</li>
</ul>
</li>
<li>参数3：共享内存管理结构体</li>
</ul>
</li>
<li>共享内存的删除叫做标记删除：删除一段共享内存时，该内存正在使用（连接数不为0），不会立即删除，而是等待该内存不再被使用时，才会真正地删除。</li>
</ol>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode远程开发免密登录</title>
    <url>/2021/11/13/vscode%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<ol>
<li>开发机进入cmd界面，输入<code>ssh-keygen</code>生成密钥。</li>
<li>将id_rsa.pub传入服务器。</li>
<li>输入命令<code>cat id_rsa.pub &gt;&gt; authorized_keys</code>。</li>
</ol>
]]></content>
      <tags>
        <tag>VSCode</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
</search>
