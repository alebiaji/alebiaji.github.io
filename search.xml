<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言学习整理01</title>
    <url>/2021/06/29/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%8601/</url>
    <content><![CDATA[<h1 id="c语言学习整理01"><a class="markdownIt-Anchor" href="#c语言学习整理01"></a> C语言学习整理01</h1>
<ol>
<li><strong>Linux进程地址空间图</strong></li>
</ol>
<img src="/images/进程地址空间.png" alt="img 进程地址空间" style="zoom: 80%;">
<span id="more"></span>
<ol start="2">
<li><strong>编译过程</strong></li>
</ol>
<img src="/images/编译过程.png" alt="img 进程地址空间" style="zoom: 80%;">
<ol start="3">
<li>
<p>变量是有名字的内存空间，其内存空间由数据类型决定大小和解释方式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1B = 8bit</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">int</span>) = <span class="number">4B</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">char</span>) = <span class="number">1B</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">long</span>) = <span class="number">4B</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">short</span>) = <span class="number">2B</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">float</span>) = <span class="number">4B</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">double</span>) = <span class="number">8B</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">void</span> *) = <span class="number">8B</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) = <span class="number">8B</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不同进制数的输出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//十进制输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;123 = %d\n&quot;</span>, <span class="number">123</span>);	</span><br><span class="line">    <span class="comment">//八进制输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0123 = %d\n&quot;</span>, <span class="number">0123</span>);	</span><br><span class="line">    <span class="comment">//十六进制输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x123 = %d\n&quot;</span>, <span class="number">0x123</span>);	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">123 = 123</span></span><br><span class="line"><span class="comment">0123 = 83</span></span><br><span class="line"><span class="comment">0x123 = 291</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>x进制 -&gt; 10进制：<br>
<img src="/images/x进制转10进制.png" alt="img x进制转10进制"><br>
2进制 -&gt; 8进制：每三位为一组</p>
<p>2进制 -&gt; 16进制：每四位为一组</p>
<p><strong>10进制 -&gt; 2进制</strong>：<a href="https://baike.baidu.com/item/%E9%99%A4k%E5%8F%96%E4%BD%99%E6%B3%95/19385576?fr=aladdin">除2取余法</a></p>
</li>
<li>
<p>内存中一般用<strong>小端存储</strong><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>法存储数据，int占据4个字节，a的地址是addr_a，b的地址是addr_b，根据以下代码说明变量a和b的真值、机器数和内存布局（每个字节的内容）分别如何？还有一种<strong>大端存储</strong><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ... //</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">-1234</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2345</span>;</span><br><span class="line"><span class="comment">// ... //</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>变量a</th>
<th>变量b</th>
</tr>
</thead>
<tbody>
<tr>
<td>真值</td>
<td>-1234</td>
<td>2345</td>
</tr>
<tr>
<td>机器数</td>
<td>FF FF FB 2E</td>
<td>00 00 09 29</td>
</tr>
<tr>
<td>内存布局</td>
<td>2E FB FF FF</td>
<td>29 09 00 00</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a href="https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613?fr=aladdin">补码</a>：有符号整型在计算机中采取补码的编码方式，通过给一个数补上一个周期，把减法变成加法。</p>
<ul>
<li>
<p>正整数：正整数的补码与原码相同。</p>
</li>
<li>
<p>负整数：负整数的补码是将其除<strong>符号位</strong><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>以外，其余所有位取反后加1。</p>
</li>
<li>
<p>0：0的补码是唯一表示的。</p>
</li>
</ul>
</li>
<li>
<p>根据机器数的大小比较真值的大小</p>
<ol>
<li>符号不同，正数 &gt; 负数</li>
<li>符号相同，机器数越大，真值越大</li>
<li>
<ul>
<li>最大负整数：1,111 1111 … = -1</li>
<li>最小负整数：1,000 0000 … = -2^(n-1)</li>
<li>最大正整数：0,111 1111 … = 2^(n-1) - 1</li>
<li>可表示的范围：-2^(n-1) ~ 2^(n-1) - 1</li>
</ul>
</li>
</ol>
</li>
<li>
<p>机器数相同，真值不一定相同，真值由解释方式决定。</p>
</li>
<li>
<p>两个有符号数的加法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">机器数1 + 机器数2 = 机器数3 -&gt; (用补码方式解释) 真值(可能会溢出)</span><br><span class="line"></span><br><span class="line">例题：给出两个数据-123和12，如果采用原码方式，如何执行加法运算；如果是补码方式，如何执行加法运算？说明在原码加法和补码加法中，分别在哪些步骤中使用了加法器、减法器和大小比较器。</span><br><span class="line"></span><br><span class="line">解：-123和12</span><br><span class="line">原码加法:</span><br><span class="line">	-123 -&gt; 1,111 1011</span><br><span class="line">	12   -&gt; 0,000 1100</span><br><span class="line">	不带符号位参与运算，判断两数绝对值，用绝对值大的减去绝对值小的，符号位与绝对值大的相同。(大小比较器)</span><br><span class="line">	111 1011 - 000 1100 = 110 0111 -&gt; 1,110 1111(减法器)</span><br><span class="line">补码加法:</span><br><span class="line">	-123 -&gt; 1,000 0101</span><br><span class="line">	12   -&gt; 0,000 1100</span><br><span class="line">	负数的补码为符号位不变，原码取反+1，带符号位参与加法运算。负数结果数值位取反+1。</span><br><span class="line">	1,000 0101 + 0,000 1100 = 1,001 0001 -&gt; 1,110 1111(加法器)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h1 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h1>
<ol>
<li>
<p>打印九九乘法表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1*1 = 1</span><br><span class="line">1*2 = 2 2*2 = 4</span><br><span class="line">1*3 = 3 2*3 = 6 3*3 = 9</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;func.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//从1开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i)&#123;</span><br><span class="line">        <span class="comment">//j &lt;= i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%-2d * %-2d = %-2d &quot;</span>, j, i, j * i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>打印图案</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    *</span><br><span class="line">   * *</span><br><span class="line">  * * *</span><br><span class="line"> * * * *</span><br><span class="line">* * * * *</span><br><span class="line"> * * * *</span><br><span class="line">  * * *</span><br><span class="line">   * *</span><br><span class="line">    *</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">//上三角形边长</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//打印正三角</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="comment">//打印N - 1 - i个空格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印i + 1个*，每个*中间有一个空格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span> * i; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印倒三角</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//打印N - 1 - i个空格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印i + 1个*，每个*中间有一个空格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span> * i; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>打印图案</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    *</span><br><span class="line">   * *</span><br><span class="line">  *   *</span><br><span class="line"> *     *</span><br><span class="line">*       *</span><br><span class="line"> *     *</span><br><span class="line">  *   *</span><br><span class="line">   * *</span><br><span class="line">    *</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">//上三角形边长</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="comment">//打印N - 1 - i个空格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//边界打印*，其余打印空格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span> * i; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span> || k == <span class="number">2</span> * i)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span> * i; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span> || k == <span class="number">2</span> * i)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>打印图案</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   * *       * *</span><br><span class="line">  * * *     * * *</span><br><span class="line"> * * * *   * * * *</span><br><span class="line">* * * * * * * * * *</span><br><span class="line"> * * * * * * * * *</span><br><span class="line">  * * * * * * * *</span><br><span class="line">   * * * * * * *</span><br><span class="line">    * * * * * * </span><br><span class="line">     * * * * *</span><br><span class="line">      * * * *</span><br><span class="line">       * * *</span><br><span class="line">        * *</span><br><span class="line">         *</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*利用第二题思想将图形分为</span></span><br><span class="line"><span class="comment">   * *       * *</span></span><br><span class="line"><span class="comment">  * * *     * * *</span></span><br><span class="line"><span class="comment"> * * * *   * * * *</span></span><br><span class="line"><span class="comment">* * * * * * * * * *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">和</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * * * * * * * * *</span></span><br><span class="line"><span class="comment">  * * * * * * * *</span></span><br><span class="line"><span class="comment">   * * * * * * *</span></span><br><span class="line"><span class="comment">    * * * * * * </span></span><br><span class="line"><span class="comment">     * * * * *</span></span><br><span class="line"><span class="comment">      * * * *</span></span><br><span class="line"><span class="comment">       * * *</span></span><br><span class="line"><span class="comment">        * *</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//打印驼峰</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N / <span class="number">2</span> - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span> * i; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span> + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span> * i; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印下三角</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N - <span class="number">2</span> - i; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span> * i; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>数据的高字节存储在高地址中，数据的低字节存储在低地址中 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>数据的高字节存储在低地址中，数据的低字节存储在高地址中 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>取最高位为符号位 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile学习</title>
    <url>/2021/07/10/Makefile%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="makefile"><a class="markdownIt-Anchor" href="#makefile"></a> Makefile</h1>
<h4 id="功能通过makefile文件来描述源程序之间的相互关系并自动维护编译工作"><a class="markdownIt-Anchor" href="#功能通过makefile文件来描述源程序之间的相互关系并自动维护编译工作"></a> 功能：通过makefile文件来描述源程序之间的相互关系并自动维护编译工作。</h4>
<span id="more"></span>
<ol>
<li>
<p>Makefile的变量：</p>
<ol>
<li>
<p>自定义变量：<strong>字符串(变量名):=字符串(变量值)</strong>，可通过$(变量名)替代所有的变量值。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#未使用自定义变量</span></span><br><span class="line"><span class="section">main:main.c</span></span><br><span class="line">	gcc main.c -o main</span><br><span class="line">----------------------------</span><br><span class="line"><span class="comment">#使用自定义变量</span></span><br><span class="line">target:=main</span><br><span class="line">src:=main.c</span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(src)</span></span><br><span class="line">	gcc <span class="variable">$(src)</span> -o <span class="variable">$(target)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>自动变量：随规则的变化，同一个变量名对应不同的变量值</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>$@</td>
<td>目标文件</td>
</tr>
<tr>
<td>$&lt;</td>
<td>第一个依赖文件</td>
</tr>
<tr>
<td>$^</td>
<td>所有的依赖文件，以空格分隔</td>
</tr>
<tr>
<td>$?</td>
<td>日期新于目标文件的所有相关文件列表，逗号分隔</td>
</tr>
<tr>
<td>$(@D)</td>
<td>目标文件的目录名部分</td>
</tr>
<tr>
<td>$(@F)</td>
<td>目标文件的文件名部分</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>预定义的变量：有预定义的变量，可以手动其修改含义</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>含义</th>
<th>变量值</th>
</tr>
</thead>
<tbody>
<tr>
<td>AR</td>
<td>打包库文件</td>
<td>ar</td>
</tr>
<tr>
<td>AS</td>
<td>汇编程序</td>
<td>as</td>
</tr>
<tr>
<td>CC</td>
<td>C编译器</td>
<td>cc</td>
</tr>
<tr>
<td>CPP</td>
<td>CPP编译器</td>
<td>$(CC) -E</td>
</tr>
<tr>
<td>CXX</td>
<td>C++编译器</td>
<td>g++</td>
</tr>
<tr>
<td>RM</td>
<td>删除</td>
<td>rm -f</td>
</tr>
</tbody>
</table>
</li>
</ol>
</li>
<li>
<p>wildcard：从文件系统中提取文件名(按照通配符规则)</p>
<p>subst/patsubst：文本替换/按格式文本替换</p>
   <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">srcs:=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span> <span class="comment">#srcs为目录下所有.c文件</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">var:=<span class="string">&quot;How are you&quot;</span></span><br><span class="line">newvar:=<span class="variable">$(<span class="built_in">patsubst</span> you,me,<span class="variable">$(var)</span>)</span> <span class="comment">#将var中所有的you替换成me</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">srcs:=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span> </span><br><span class="line">objs:=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(srcs)</span>)</span> <span class="comment">#将srcs中所有的.c文件替换成.o文件</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>%<strong>匹配字符：从上一个规则的</strong>依赖条件</strong>中按照匹配格式匹配内容，每次匹配成功就生成一个规则，<strong>%<strong>表示匹配得到的内容。(在变量引用时使用</strong>%</strong>)</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">srcs:$(wildcard *.c) </span></span><br><span class="line"><span class="section">objs:$(patsubst %.c,%,<span class="variable">$(srcs)</span>) #匹配srcs中所有的.c文件替换成.o文件</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>for循环：</p>
   <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">srcs:=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">exes:=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%,<span class="variable">$(srcs)</span>)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    for i in <span class="variable">$(exes)</span>; do <span class="variable">$(CC)</span> $$i.c -o $$i; done <span class="comment">#$$i代表$(exes)中的内容</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>伪目标：以不存在的文件作为命令的目标(每次make都会执行)，常用<code>.PHONY</code>来区分伪目标方便阅读。</p>
</li>
<li>
<p>增量编译：</p>
   <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC:=gcc                                                                        </span><br><span class="line">srcs:=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">objs:=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(srcs)</span>)</span></span><br><span class="line">final:=main</span><br><span class="line"><span class="section">all:<span class="variable">$(final)</span></span></span><br><span class="line"><span class="variable">$(final)</span>:<span class="variable">$(objs)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:rebuild clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$(objs)</span> <span class="variable">$(final)</span></span><br><span class="line"><span class="section">rebuild:clean all </span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编译所有.c文件得到可执行文件</p>
   <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC:=gcc                                                                        </span><br><span class="line">srcs:=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">exes:=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%,<span class="variable">$(srcs)</span>)</span></span><br><span class="line"><span class="section">all:<span class="variable">$(exes)</span></span></span><br><span class="line"><span class="section">%:%.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:rebuild clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$(exes)</span></span><br><span class="line"><span class="section">rebuild:clean all</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown学习</title>
    <url>/2021/06/28/Markdown%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="markdown语法学习"><a class="markdownIt-Anchor" href="#markdown语法学习"></a> Markdown语法学习</h1>
<span id="more"></span>
<p><a href="https://www.runoob.com/markdown/md-link.html">学自菜鸟</a></p>
<ol>
<li>用=和-标记一二级标题</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">我是一级标题</span></span><br><span class="line"><span class="section">=================</span></span><br><span class="line"></span><br><span class="line"><span class="section">我是二级标题</span></span><br><span class="line"><span class="section">-----------------</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>用#标记标题(共6级)</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>换行：<strong>两个空格 + 回车</strong></p>
</li>
<li>
<p>字体加粗or斜体</p>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span></span><br><span class="line"><span class="strong">**粗体**</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体<span class="strong">**<span class="emphasis">*</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong">_斜体_</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong"><span class="strong">__粗体__</span></span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong"><span class="strong">__<span class="emphasis">_粗斜体<span class="strong">__<span class="emphasis">_</span></span></span></span></span></span></span></span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>分割线：可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> <span class="emphasis">* *</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> - -</span><br><span class="line"></span><br><span class="line"><span class="emphasis">_ _</span> <span class="emphasis">_</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li><s>删除线</s>：文字两端加~~</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure>
<ol start="7">
<li><u>下划线</u>：使用HTML中的<code>&lt;u&gt;</code>标签实现</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线<span class="xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ol start="8">
<li><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[^脚注]</span><br></pre></td></tr></table></figure>
<ol start="9">
<li>
<p>无序列表：用(*)(+)(-)后加一个空格表示</p>
</li>
<li>
<p>有序列表：用数字加上.再加一个空格表示</p>
</li>
<li>
<p>Markdown区块：段落开头使用<code>&gt;</code>符号，后面跟一个空格(可以嵌套)</p>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 区块</span></span><br><span class="line"><span class="quote">&gt; &gt; 嵌套</span></span><br></pre></td></tr></table></figure>
<ol start="12">
<li>Markdown链接：</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">链接名</span>](<span class="link">链接地址</span>)</span><br><span class="line">或者</span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure>
<ol start="13">
<li>Markdown图片：</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">name 属性文本</span>](<span class="link">图片地址 &quot;可选标题&quot;</span>)</span><br><span class="line"></span><br><span class="line">可以用<span class="xml"><span class="tag">&lt;<span class="name">img</span>&gt;</span></span>标签指定高度和宽度：<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片地址&quot;</span> <span class="attr">width</span> = <span class="string">&quot;xx%&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ol start="14">
<li>转义：</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">使用\能够正常显示特殊字符，如：</span><br><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line"><span class="bullet">*</span>   星号</span><br><span class="line"><span class="emphasis">_   下划线</span></span><br><span class="line"><span class="emphasis">&#123;&#125;  花括号</span></span><br><span class="line"><span class="emphasis">[]  方括号</span></span><br><span class="line"><span class="emphasis">()  小括号</span></span><br><span class="line"><span class="emphasis">#   井字号</span></span><br><span class="line"><span class="emphasis">+   加号</span></span><br><span class="line"><span class="emphasis">-   减号</span></span><br><span class="line"><span class="emphasis">.   英文句点</span></span><br><span class="line"><span class="emphasis">!   感叹号</span></span><br></pre></td></tr></table></figure>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>要脚注的文字 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/06/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2>
<h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>进程池</title>
    <url>/2021/07/12/%E8%BF%9B%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="进程池流程"><a class="markdownIt-Anchor" href="#进程池流程"></a> 进程池流程</h1>
<h2 id="目的实现多个客户端同时访问服务器获得服务本文例子为下载文件"><a class="markdownIt-Anchor" href="#目的实现多个客户端同时访问服务器获得服务本文例子为下载文件"></a> 目的：实现多个客户端同时访问服务器获得服务(本文例子为下载文件)</h2>
<span id="more"></span>
<h2 id="好处1-降低资源消耗2-提高响应速度3-提高进程的可管理性"><a class="markdownIt-Anchor" href="#好处1-降低资源消耗2-提高响应速度3-提高进程的可管理性"></a> 好处：1. 降低资源消耗；2. 提高响应速度；3. 提高进程的可管理性。</h2>
<h2 id="主要工作流程"><a class="markdownIt-Anchor" href="#主要工作流程"></a> 主要工作流程：</h2>
<ul>
<li>父进程：
<ol>
<li>循环创建子进程，记录子进程的相关信息(子进程进程ID，进程的状态，子进程与服务端通信时的文件描述符)。查看是否创建成功：<code>ps -elf | grep [端口号]</code>可以查看子进程是否创建成功。</li>
<li>创建TCP监听套接字，等待客户端的连接请求，查看是否再监听：<code>netstat -nat</code>需要安装。</li>
<li>创建epoll，把需要监听的文件描述符都添加到epoll中，子进程与服务器通信的文件描述符也要加入到epoll当中。</li>
<li>如果客户端请求服务器，使用accept函数接收这次连接请求并返回一个用于与客户端通信的文件描述符，将其发送给子进程(使用sendmsg发送，需要一个msg结构体)，让子进程用该文件描述符与其通信，服务客户端，并将子进程状态设置为忙碌。—&gt;转到子进程。</li>
<li>如果epoll监听到子进程发送的结束信息，主进程将子进程状态设置为不忙碌。</li>
</ol>
</li>
<li>子进程：
<ol>
<li>子进程阻塞，等待父进程发送与客户端相互通信的文件描述符(使用recvmsg函数接收)，用于服务客户端。</li>
<li>服务完客户端之后，关闭与客户端的连接，通知父进程，由父进程将子进程的工作状态设置为不忙碌。</li>
<li>继续等待下一次任务。</li>
</ol>
</li>
</ul>
<h2 id="客户端从服务器下载文件流程"><a class="markdownIt-Anchor" href="#客户端从服务器下载文件流程"></a> 客户端从服务器下载文件流程：</h2>
<ul>
<li>服务器：
<ol>
<li>发送文件名，打开文件。</li>
<li>读取文件，发送文件内容。</li>
</ol>
</li>
<li>客户端：
<ol>
<li>接收文件名，创建同名文件。</li>
<li>接收文件内容，写入同名文件。</li>
</ol>
</li>
<li>文件检测：用md5sum命令对文件计算哈希值，获得相同值说明文件传输成功。</li>
</ul>
<h1 id="服务器设计"><a class="markdownIt-Anchor" href="#服务器设计"></a> 服务器设计</h1>
<h2 id="数据结构设计"><a class="markdownIt-Anchor" href="#数据结构设计"></a> 数据结构设计：</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pipe_fd：与主进程进行通信的文件描述符</span></span><br><span class="line"><span class="comment">busy_status：子进程忙碌状态</span></span><br><span class="line"><span class="comment">pid：子进程的pid</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_BUSY 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_NO_BUSY 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">process_info_s</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> pipe_fd;</span><br><span class="line">    <span class="keyword">int</span> busy_status;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">&#125;<span class="keyword">process_info_t</span>, *pProcess_info_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">data_len：传输数据的长度</span></span><br><span class="line"><span class="comment">data_buf：传输的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data_len;</span><br><span class="line">    <span class="keyword">char</span> data_buf[<span class="number">1000</span>];</span><br><span class="line">&#125;<span class="keyword">train_t</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="程序设计"><a class="markdownIt-Anchor" href="#程序设计"></a> 程序设计：</h2>
<h3 id="mainc主程序"><a class="markdownIt-Anchor" href="#mainc主程序"></a> main.c：主程序</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.循环创建子进程，并记录子进程的相关信息</span></span><br><span class="line">    <span class="keyword">int</span> process_num = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">    pProcess_info_t pInfo = (pProcess_info_t)<span class="built_in">calloc</span>(process_num, <span class="keyword">sizeof</span>(<span class="keyword">process_info_t</span>));</span><br><span class="line">    ret = CreateProcess(pInfo, process_num);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;CreateProcess&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.创建tcp监听套接字，等待客户端连接</span></span><br><span class="line">    <span class="keyword">int</span> socket_fd = <span class="number">0</span>;</span><br><span class="line">    ret = TcpInit(argv[<span class="number">1</span>], argv[<span class="number">2</span>], &amp;socket_fd);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;TcpInit&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.创建epoll</span></span><br><span class="line">    <span class="keyword">int</span> epoll_fd = epoll_create(<span class="number">1</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把所有需要监听的描述符添加到epoll当中</span></span><br><span class="line">    EpollAddFd(epoll_fd, socket_fd);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process_num; ++i)&#123;</span><br><span class="line">        EpollAddFd(epoll_fd, pInfo[i].pipe_fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建epoll_event结构体数组，用于存储</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span>[2];</span></span><br><span class="line">    <span class="built_in">memset</span>(evs, <span class="number">0</span>, <span class="keyword">sizeof</span>(evs));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建new_fd用于接收客户端连接和数据</span></span><br><span class="line">    <span class="keyword">int</span> new_fd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示就绪的文件描述符数量</span></span><br><span class="line">    <span class="keyword">int</span> ready_fd_num = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得活跃的文件描述符数量，-1表示无条件等待</span></span><br><span class="line">        ready_fd_num = epoll_wait(epoll_fd, evs, <span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ready_fd_num; ++i)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//socket_fd就绪，服务器主进程接收连接，得到new_fd寻找空闲子进程</span></span><br><span class="line">            <span class="keyword">if</span>(evs[i].data.fd == socket_fd)&#123;</span><br><span class="line">                <span class="comment">//4.如果客户端连接服务器，使用accept接受这次连接请求，返回一个new_fd，并将new_fd交给空闲子进程</span></span><br><span class="line">                new_fd = accept(socket_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; process_num; ++j)&#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//如果该子进程不繁忙，传递文件描述符给子进程，修改子进程忙碌状态，退出循环</span></span><br><span class="line">                    <span class="keyword">if</span>(PROCESS_NO_BUSY == pInfo[j].busy_status)&#123;</span><br><span class="line">                        SendFd(pInfo[j].pipe_fd, new_fd);</span><br><span class="line">                        pInfo[j].busy_status = PROCESS_BUSY;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;process %d is busy.\n&quot;</span>, pInfo[j].pid);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//传给子进程的new_fd和子进程获取的new_fd指向同一片区域但数值不相同，因此关闭主进程的new_fd不影响子进程对new_fd的读写</span></span><br><span class="line">                close(new_fd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环遍历子进程的pipe_fd看是否有就绪的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; process_num; ++j)&#123;</span><br><span class="line">                <span class="comment">//5.epoll监听到pipe_fd可读，表示子进程工作完成，把子进程工作状态置为空闲</span></span><br><span class="line">                <span class="keyword">if</span>(evs[i].data.fd == pInfo[j].pipe_fd)&#123;</span><br><span class="line">                    <span class="comment">//用于接收子进程完成的信息</span></span><br><span class="line">                    <span class="keyword">char</span> buf[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                    ret = read(pInfo[j].pipe_fd, buf, <span class="number">2</span>);</span><br><span class="line">                    pInfo[j].busy_status = PROCESS_NO_BUSY;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;process %d is not busy.\n&quot;</span>, pInfo[j].pid);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="createprocessc创建子进程"><a class="markdownIt-Anchor" href="#createprocessc创建子进程"></a> CreateProcess.c：创建子进程</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreateProcess</span><span class="params">(pProcess_info_t pInfo,<span class="keyword">int</span> process_num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process_num; ++i)&#123;</span><br><span class="line">        <span class="comment">//创建一对相连的套接口，类似于全双工管道，只能在本机中使用</span></span><br><span class="line">        ret = socketpair(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>, fds);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;socketpair&quot;</span>);</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == pid)&#123;</span><br><span class="line">            close(fds[<span class="number">0</span>]);</span><br><span class="line">            ChildFunc(fds[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fds[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//记录子进程的相关信息</span></span><br><span class="line">        pInfo[i].pid = pid;</span><br><span class="line">        pInfo[i].pipe_fd = fds[<span class="number">1</span>];</span><br><span class="line">        pInfo[i].busy_status = PROCESS_NO_BUSY;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="childfuncc子进程函数用于写对客户端的服务"><a class="markdownIt-Anchor" href="#childfuncc子进程函数用于写对客户端的服务"></a> ChildFunc.c：子进程函数，用于写对客户端的服务</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ChildFunc</span><span class="params">(<span class="keyword">int</span> pipe_fd)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用client_fd接收从主进程传来的new_fd</span></span><br><span class="line">    <span class="keyword">int</span> client_fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.调用RecvFd函数用于接收与客户端通信的client_fd</span></span><br><span class="line">        ret = RecvFd(pipe_fd, &amp;client_fd);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;RecvFd&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.传输文件给客户端，不需要报错，报错正常执行，不能因为客户端导致服务器崩溃</span></span><br><span class="line">        TransFile(client_fd);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.通知父进程服务完成</span></span><br><span class="line">        ret = write(pipe_fd, <span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;write&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.关闭client_fd</span></span><br><span class="line">        close(client_fd);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="recvfdc子进程接收主进程发送的与客户端通信的文件描述符"><a class="markdownIt-Anchor" href="#recvfdc子进程接收主进程发送的与客户端通信的文件描述符"></a> RecvFd.c：子进程接收主进程发送的与客户端通信的文件描述符</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RecvFd</span><span class="params">(<span class="keyword">int</span> pipe_fd, <span class="keyword">int</span> *new_fd)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建sendmsg可用的数据结构体msg，并初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建msg中的iovec结构体iov，并初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;iov, <span class="number">0</span>, <span class="keyword">sizeof</span>(iov));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//iovec必须要赋值</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    iov.iov_base = buf;</span><br><span class="line">    iov.iov_len = <span class="built_in">strlen</span>(buf);</span><br><span class="line"></span><br><span class="line">    msg.msg_iov = &amp;iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//因为cmsg中有个柔性数组，所以只能申请堆空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cmsg</span> =</span> (struct cmsghdr*)<span class="built_in">calloc</span>(<span class="number">1</span>, len);</span><br><span class="line">    cmsg-&gt;cmsg_len = len;</span><br><span class="line">    cmsg-&gt;cmsg_level = SOL_SOCKET;</span><br><span class="line">    cmsg-&gt;cmsg_type = SCM_RIGHTS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//msg的附属数据结构体指向cmsg</span></span><br><span class="line">    msg.msg_control = cmsg;</span><br><span class="line">    msg.msg_controllen = len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用pipe_fd向子进程接收msg</span></span><br><span class="line">    <span class="comment">//用ssize_t recvmsg(int sockfd, const struct msghdr *msg, int flags)可以发送文件描述符</span></span><br><span class="line">    recvmsg(pipe_fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//柔性数组的数据用CMSG_DATA()接收，要进行类型转换</span></span><br><span class="line">    *new_fd = *(<span class="keyword">int</span>*)CMSG_DATA(cmsg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="sendfdc主进程发送与客户端通信的文件描述符给子进程"><a class="markdownIt-Anchor" href="#sendfdc主进程发送与客户端通信的文件描述符给子进程"></a> SendFd.c：主进程发送与客户端通信的文件描述符给子进程</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SendFd</span><span class="params">(<span class="keyword">int</span> pipe_fd, <span class="keyword">int</span> new_fd)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建sendmsg可用的数据结构体msg，并初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建msg中的iovec结构体iov，并初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;iov, <span class="number">0</span>, <span class="keyword">sizeof</span>(iov));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//iovec必须要赋值</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    iov.iov_base = buf;</span><br><span class="line">    iov.iov_len = <span class="built_in">strlen</span>(buf);</span><br><span class="line"></span><br><span class="line">    msg.msg_iov = &amp;iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//因为cmsg中有个柔性数组，所以只能申请堆空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cmsg</span> =</span> (struct cmsghdr*)<span class="built_in">calloc</span>(<span class="number">1</span>, len);</span><br><span class="line">    cmsg-&gt;cmsg_len = len;</span><br><span class="line">    cmsg-&gt;cmsg_level = SOL_SOCKET;</span><br><span class="line">    cmsg-&gt;cmsg_type = SCM_RIGHTS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//柔性数组的数据用CMSG_DATA()接收，要进行类型转换</span></span><br><span class="line">    *(<span class="keyword">int</span>*)CMSG_DATA(cmsg) = new_fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//msg的附属数据结构体指向cmsg</span></span><br><span class="line">    msg.msg_control = cmsg;</span><br><span class="line">    msg.msg_controllen = len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用pipe_fd向子进程发送msg</span></span><br><span class="line">    <span class="comment">//用ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags)可以发送文件描述符</span></span><br><span class="line">    sendmsg(pipe_fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="transfilec文件传输函数"><a class="markdownIt-Anchor" href="#transfilec文件传输函数"></a> TransFile.c：文件传输函数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接收一次SIGPIPE信号，防止信号中断程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigfunc</span><span class="params">(<span class="keyword">int</span> signum)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGPIPE is coimg&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TransFile</span><span class="params">(<span class="keyword">int</span> client_fd)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    signal(SIGPIPE, sigfunc);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;1.pdf&quot;</span>, O_RDONLY);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;open&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前文件的状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">fileInfo</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;fileInfo, <span class="number">0</span>, <span class="keyword">sizeof</span>(fileInfo));</span><br><span class="line">    ret = fstat(fd, &amp;fileInfo);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;fstat&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建传输数据结构体</span></span><br><span class="line">    <span class="keyword">train_t</span> train;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;train, <span class="number">0</span>, <span class="keyword">sizeof</span>(train));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送文件名</span></span><br><span class="line">    train.data_len = <span class="built_in">strlen</span>(<span class="string">&quot;1.pdf&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(train.data_buf, <span class="string">&quot;1.pdf&quot;</span>);</span><br><span class="line">    ret = send(client_fd, &amp;train, <span class="number">4</span> + train.data_len, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;send&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;train, <span class="number">0</span>, <span class="keyword">sizeof</span>(train));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送文件大小</span></span><br><span class="line">    train.data_len = <span class="keyword">sizeof</span>(fileInfo.st_size);</span><br><span class="line">    <span class="built_in">memcpy</span>(train.data_buf, &amp;fileInfo.st_size, <span class="keyword">sizeof</span>(<span class="keyword">off_t</span>));</span><br><span class="line">    send(client_fd, &amp;train, <span class="number">4</span> + train.data_len, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fileSize = %ld\n&quot;</span>, fileInfo.st_size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//----------------------------------零拷贝修改区----------------------------------//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;train, <span class="number">0</span>, <span class="keyword">sizeof</span>(train));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环文件发送数据</span></span><br><span class="line">        train.data_len = read(fd, train.data_buf, <span class="keyword">sizeof</span>(train.data_buf));</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == train.data_len)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送错误则退出发送</span></span><br><span class="line">        ret = send(client_fd, &amp;train, train.data_len + <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;TransFile_send&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//发送数据为0时退出循环</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == train.data_len)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//----------------------------------零拷贝修改区----------------------------------//</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="tcpinitc创建主进程的tcp监听套接字"><a class="markdownIt-Anchor" href="#tcpinitc创建主进程的tcp监听套接字"></a> TcpInit.c：创建主进程的TCP监听套接字</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TcpInit</span><span class="params">(<span class="keyword">char</span> *ip, <span class="keyword">char</span>*port, <span class="keyword">int</span> *socket_fd)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="comment">/*分别设置协议、IP地址和端口号*/</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line">    addr.sin_port = htons(atoi(port));</span><br><span class="line"></span><br><span class="line">    *socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(*socket_fd, <span class="number">-1</span>, <span class="string">&quot;socket&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置地址可重用</span></span><br><span class="line">    <span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">    ret = setsockopt(*socket_fd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置缓冲区大小</span></span><br><span class="line">    <span class="keyword">int</span> buf = <span class="number">65536</span>;</span><br><span class="line">    ret = setsockopt(*socket_fd, SOL_SOCKET, SO_SNDBUF, &amp;buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绑定ip地址和端口号</span></span><br><span class="line">    ret = bind(*socket_fd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;bind&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听描述符，最大连接数设置为10</span></span><br><span class="line">    ret = listen(*socket_fd, <span class="number">10</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;ret&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="epolladdfdc将文件描述符添加进epoll"><a class="markdownIt-Anchor" href="#epolladdfdc将文件描述符添加进epoll"></a> EpollAddFd.c：将文件描述符添加进epoll</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EpollAddFd</span><span class="params">(<span class="keyword">int</span> epoll_fd, <span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;events, <span class="number">0</span>, <span class="keyword">sizeof</span>(events));</span><br><span class="line">    events.events = EPOLLIN;</span><br><span class="line">    events.data.fd = fd;</span><br><span class="line">    <span class="comment">//将fd添加进epoll</span></span><br><span class="line">    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;events);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="客户端设计"><a class="markdownIt-Anchor" href="#客户端设计"></a> 客户端设计</h1>
<h2 id="程序设计-2"><a class="markdownIt-Anchor" href="#程序设计-2"></a> 程序设计</h2>
<h3 id="clientc客户端主程序"><a class="markdownIt-Anchor" href="#clientc客户端主程序"></a> client.c：客户端主程序</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存服务器端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套接字文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(socket_fd, <span class="number">-1</span>, <span class="string">&quot;socket&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置接收缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> recv_buf = <span class="number">65536</span>;</span><br><span class="line">    ret = setsockopt(socket_fd, SOL_SOCKET, SO_RCVBUF, &amp;recv_buf, <span class="keyword">sizeof</span>(recv_buf));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    ret = connect(socket_fd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;connect&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> data_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">off_t</span> file_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.先接收文件名长度</span></span><br><span class="line">    ret = recv(socket_fd, &amp;data_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;recv_name_len&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.根据文件名长度接收文件名</span></span><br><span class="line">    ret = recv(socket_fd, buf, data_len, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;recv_name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.接收文件大小</span></span><br><span class="line">    ret = recv(socket_fd, &amp;data_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">    ret = recv(socket_fd, &amp;file_len, data_len, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.根据文件名打开文件</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(buf, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    ERROR_CHECK(fd, <span class="number">-1</span>, <span class="string">&quot;open&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------------------------零拷贝修改区----------------------------------//</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置接收文件的大小</span></span><br><span class="line">    <span class="keyword">off_t</span> file_len_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计次数打印进度条</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//!!!!!!!!!!!!!!!!!!!!!!!!清空缓冲区!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.接收文件长度</span></span><br><span class="line">        recv(socket_fd, &amp;data_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == data_len)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.接收文件数据</span></span><br><span class="line">        ret = RecvFile(socket_fd, buf, data_len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.统计现有文件大小，打印进度条</span></span><br><span class="line">        file_len_num += ret;</span><br><span class="line">        cnt = PrintProgressRate(file_len, file_len_num, cnt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.写入文件</span></span><br><span class="line">        write(fd, buf, data_len);</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------------------------零拷贝修改区----------------------------------//</span></span><br><span class="line"></span><br><span class="line">    close(socket_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="recvfilec封装一个接收指定大小数据的函数"><a class="markdownIt-Anchor" href="#recvfilec封装一个接收指定大小数据的函数"></a> RecvFile.c：封装一个接收指定大小数据的函数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RecvFile</span><span class="params">(<span class="keyword">int</span> socket_fd, <span class="keyword">void</span> *buf, <span class="keyword">int</span> data_len)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> get_file_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(get_file_len &lt; data_len)&#123;</span><br><span class="line">        <span class="comment">//动态接收数据，等到接收数据达到想要接受的长度时退出</span></span><br><span class="line">        ret = recv(socket_fd, (<span class="keyword">char</span> *)buf + get_file_len, data_len - get_file_len, <span class="number">0</span>);</span><br><span class="line">        get_file_len += ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> get_file_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="printprogressratec打印进度条程序"><a class="markdownIt-Anchor" href="#printprogressratec打印进度条程序"></a> PrintProgressRate.c：打印进度条程序</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PrintProgressRate</span><span class="params">(<span class="keyword">off_t</span> final_num, <span class="keyword">off_t</span> now_num, <span class="keyword">int</span> cnt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> all = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">2</span>] = <span class="string">&quot;%&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(final_num == now_num)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; all; ++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;█&quot;</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;100.00%s\n&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">100</span> == ++cnt)&#123;</span><br><span class="line">        <span class="keyword">double</span> bar = (<span class="keyword">double</span>)now_num / final_num * <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> space_num = all - (<span class="keyword">int</span>)bar / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; all - space_num; ++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;█&quot;</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; space_num - <span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5.2lf%s\r&quot;</span>, bar, str);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="遇到的问题"><a class="markdownIt-Anchor" href="#遇到的问题"></a> 遇到的问题</h1>
<ol>
<li>发送文件名和文件数据粘在一块。
<ul>
<li>原因：TCP粘包问题，多次发送的数据被一次接收，数据之间没有分界线，所有数据都粘在一起。</li>
<li>解决方法：人为去设计一个结构体，规定数据与数据之间的分界线(私有协议)。</li>
</ul>
</li>
<li>客户端接收文件时，接收到的文件和服务器上的文件大小内容不一样，但是传输过程没有问题。
<ul>
<li>原因：循环接收时没有清空接收缓冲区，导致错误接收。</li>
<li>解决办法：清空接收缓冲区。</li>
</ul>
</li>
<li>客户端报栈损坏、段错误。
<ul>
<li>原因：由于发送速度不匹配，造成客户端接收数据时读取数据时不一定时正确的顺序。读取认为规定的结构体时发生错误的读取，读取到错误的数据长度，导致客户端访问到了不能访问的内存空间因此程序崩溃。</li>
<li>解决方案：①设置recv的标志位为MSG_WAITALL；②封装自己的recv函数规定接收数据大小；③写一个ERROR_CHECK()宏检测，检测到错误即使返回。</li>
</ul>
</li>
<li>客户端主动退出，服务器崩溃。
<ul>
<li>原因：服务器子程序发送失败时，用了一个ERROR_CHECK()宏检测，导致子进程异常退出，父进程与子进程间通信的文件描述符成为一个无效的文件描述符，子进程会循环发送SIGPIPE信号。</li>
<li>解决办法：传输文件处写一个signal函数捕捉SIGPIPE信号。子进程传输失败时不予理会，当作服务完成，正常向后执行（<strong>不能因为客户端的问题引起服务器崩溃</strong>）。</li>
</ul>
</li>
</ol>
<h1 id="后续可以做的改进"><a class="markdownIt-Anchor" href="#后续可以做的改进"></a> 后续可以做的改进</h1>
<ol>
<li>
<p>零拷贝传输：先前传输文件时循环调用send系统调用，发生用户态到内核态再由内核态到用户态的拷贝，使用零拷贝技术，减少内核态和用户台之间的拷贝次数，从而加快服务器传输速率。</p>
<p>客户端使用零拷贝技术接收（修改client.c的修改区使用mmap）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">beg</span>, <span class="title">end</span>;</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp;beg, <span class="number">0</span>, <span class="keyword">sizeof</span>(beg));</span><br><span class="line">   <span class="built_in">memset</span>(&amp;end, <span class="number">0</span>, <span class="keyword">sizeof</span>(end));</span><br><span class="line">   </span><br><span class="line">   gettimeofday(&amp;beg, <span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line">   ftruncate(fd, file_len);</span><br><span class="line">   <span class="comment">//用mmap进行地址映射</span></span><br><span class="line">   <span class="keyword">char</span> *<span class="built_in">map</span> = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, file_len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">   ERROR_CHECK(<span class="built_in">map</span>, (<span class="keyword">char</span> *)<span class="number">-1</span>, <span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   recv(socket_fd, <span class="built_in">map</span>, file_len, MSG_WAITALL);</span><br><span class="line">   </span><br><span class="line">   munmap(<span class="built_in">map</span>, file_len);</span><br><span class="line">   </span><br><span class="line">   gettimeofday(&amp;end, <span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line"><span class="comment">//可以统计传输效率</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;total time = %lf\n&quot;</span>, (end.tv_sec - beg.tv_sec) + ((end.tv_usec - beg.tv_usec) / <span class="number">1000.0</span>) / <span class="number">1000.0</span>);</span><br></pre></td></tr></table></figure>
<p>服务器的三种零拷贝技术（修该TransFile.c的修改区）：</p>
<ul>
<li>
<p>mmap文件映射：传输240M文件0.9s左右</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.用mmap进行地址映射</span></span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">map</span> = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, fileInfo.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>); </span><br><span class="line">ERROR_CHECK(<span class="built_in">map</span>, (<span class="keyword">void</span> *)<span class="number">-1</span>, <span class="string">&quot;mmap&quot;</span>); </span><br><span class="line"><span class="comment">//发送整个map </span></span><br><span class="line">send(client_fd, <span class="built_in">map</span>, fileInfo.st_size, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//解映射</span></span><br><span class="line">munmap(<span class="built_in">map</span>, fileInfo.st_size);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>sendfile函数：传输240M文件0.7s左右</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ssize_t sendfile(int out_fd, int fd, off_t *offset, size_t count)</span></span><br><span class="line"><span class="comment">成功返回发送的字节数，失败返回-1</span></span><br><span class="line"><span class="comment">参数1：往哪写入数据</span></span><br><span class="line"><span class="comment">参数2：从哪读取数据</span></span><br><span class="line"><span class="comment">参数3：文件偏移量</span></span><br><span class="line"><span class="comment">参数4：传输数据的长度</span></span><br><span class="line"><span class="comment">sendfile只能用于发送端发送数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//2.用sendfile发送文件</span></span><br><span class="line">ret = sendfile(client_fd, fd, <span class="number">0</span>, fileInfo.st_size);</span><br><span class="line">ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;sendfile&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>splice函数：传输240M文件，发送大小设置128时需要2.2s左右，发送大小设置为65536时需要0.7s左右</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需要打开一个宏开关：#define _GNU_SOURCE</span></span><br><span class="line"><span class="comment">需要一根管道，用于发送和接收数据</span></span><br><span class="line"><span class="comment">ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags)</span></span><br><span class="line"><span class="comment">成功返回发送的字节数，失败返回-1</span></span><br><span class="line"><span class="comment">参数1：从哪取数据</span></span><br><span class="line"><span class="comment">参数2：偏移量</span></span><br><span class="line"><span class="comment">参数3：往哪写数据</span></span><br><span class="line"><span class="comment">参数4：偏移量</span></span><br><span class="line"><span class="comment">参数5：单次写入数据长度（最多65536）---&gt;可以通过这个的大小控制传输速度</span></span><br><span class="line"><span class="comment">参数6：标识位，一般填0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//3.用户splice传输文件，要利用一根管道，用文件描述符往里写，客户端通信文件描述符从里面取</span></span><br><span class="line"><span class="keyword">long</span> send_size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fds[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">pipe(fds);</span><br><span class="line"><span class="keyword">while</span>(send_size &lt; fileInfo.st_size)&#123;</span><br><span class="line">    ret = splice(fd, <span class="number">0</span>, fds[<span class="number">1</span>], <span class="number">0</span>, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">    ret = splice(fds[<span class="number">0</span>], <span class="number">0</span>, client_fd, <span class="number">0</span>, ret, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;splice&quot;</span>);</span><br><span class="line">    send_size += ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>四种发送文件对比：</p>
<ul>
<li>文件速度：sendfile &gt; mmap &gt; send，splice可以自行控制速度。</li>
<li>限制：
<ol>
<li>sendfile和mmap有文件大小限制，最大可以传输2G的大文件。</li>
<li>零拷贝接口的可移植性不是很好。</li>
<li>数据传输的瓶颈始终在于<strong>网络状态</strong>。</li>
</ol>
</li>
</ul>
</li>
<li>
<p>进程池的退出。</p>
<ul>
<li>
<p>暴力退出：父进程收到退出信号后，依次杀死子进程。</p>
<p>服务器main.c添加一个全局变量out标识符，一个信号捕捉函数和一个信号处理函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局out标识位</span></span><br><span class="line"><span class="keyword">short</span> out = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main_sigfunc</span><span class="params">(<span class="keyword">int</span> signum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">10</span> == signum)&#123;</span><br><span class="line">        out = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号捕捉函数添加在创建子进程后面，以防子进程继承主函数的信号捕捉函数</span></span><br><span class="line">signal(<span class="number">10</span>, main_sigfunc);</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴力退出子进程，加在主函数while(1)中</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> == out)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process_num; ++i)&#123;</span><br><span class="line">        kill(pInfo[i].pid, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main out\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器ChildFunc.c添加一个信号捕捉函数和处理函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">child_sigfunc</span><span class="params">(<span class="keyword">int</span> signum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">10</span> == signum)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child out\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号捕捉函数</span></span><br><span class="line">signal(<span class="number">10</span>, child_sigfunc);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>温柔退出：父进程收到退出信号后，给子进程发送退出标记，如果子进程正在忙碌，忙完后自行退出。</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信方式(1)-管道</title>
    <url>/2021/07/13/%E7%AE%A1%E9%81%93/</url>
    <content><![CDATA[<h1 id="进程间通信方式1-管道"><a class="markdownIt-Anchor" href="#进程间通信方式1-管道"></a> 进程间通信方式(1)-管道</h1>
<span id="more"></span>
<h2 id="无名管道"><a class="markdownIt-Anchor" href="#无名管道"></a> 无名管道</h2>
<ol>
<li>创建：使用<code>int pipe(int pipe_fd[2])</code>函数创建。
<ul>
<li>返回值：成功返回0，失败返回1。</li>
<li>参数是一个数组，保存的是管道两端的文件描述符，pipe_fd[1]是写端，pipe_fd[0]是读端。</li>
</ul>
</li>
<li>特点：
<ul>
<li>无名管道只能在有亲缘关系的进程间进行通信；例如父子，兄弟进程。</li>
<li>无名管道是半双工的，想要实现全双工需要建立两条无名管道。</li>
<li>依赖于文件系统，生命周期随着进程的结束而结束。</li>
<li>管道是基于字节流来通信的，数据与数据之间没有边界，多次写管道的话数据是粘在一起的。</li>
<li>管道关闭读端，然后写管道的话，程序会收到系统发送的SIGPIPE信号，中止程序，进程的退出码是141。shell中输入<code>echo $?</code>可以查看上次程序退出码，退出码大于128的进程都是呗信号打断的。</li>
<li>管道关闭写端，用read读取管道，read变成非阻塞状态，并返回0；</li>
</ul>
</li>
</ol>
<h2 id="有名管道"><a class="markdownIt-Anchor" href="#有名管道"></a> 有名管道</h2>
<ol>
<li>
<p>创建：使用<code>int mkfifo(const char *pathname, mod_t mode)</code>函数创建。</p>
<ul>
<li>返回值：成功返回0，失败返回-1。</li>
<li>参数1：管道名。</li>
<li>参数2：有名管道权限。</li>
</ul>
</li>
<li>
<p>特点：</p>
<ul>
<li>在没有亲缘关系之间的进程间进行通信。</li>
<li>是一种特殊类型的文件，不会随着进程的结束而消失。</li>
</ul>
</li>
<li>
<p>删除有名管道：使用<code>int unlink(const char *pathname)</code>函数删除。</p>
<ul>
<li>
<p>返回值：成功则返回0, 失败返回-1。</p>
</li>
<li>
<p>参数：管道/文件名。</p>
</li>
<li>
<p>不仅可以删除有名管道文件，还可以删除普通的文件。</p>
</li>
<li>
<p>实质是删除文件的连接数，当该文件的连接数为0时，才真正的删除管道/文件。</p>
</li>
</ul>
</li>
</ol>
<h2 id="标准流管道用的少"><a class="markdownIt-Anchor" href="#标准流管道用的少"></a> 标准流管道（用的少）</h2>
<ol>
<li>
<p>创建：使用<code>FILE *popen(const char *cmd, const char *type)</code>函数创建。</p>
<ul>
<li>
<p>返回值：成功返回标准I/O流，失败返回NULL。</p>
</li>
<li>
<p>参数1：启动另外一个进程。</p>
</li>
<li>
<p>参数2：打开的方式。</p>
</li>
</ul>
</li>
<li>
<p>特点：popen其实就是对管道的操作进行封装。</p>
<ol>
<li>创建一条管道。</li>
<li>fork一个子进程。</li>
<li>在父进程中关闭不需要使用的文件描述符。</li>
<li>执行exec函数族的调用。</li>
<li>执行函数中所指定的命令。</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
