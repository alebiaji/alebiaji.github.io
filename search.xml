<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Makefile</title>
    <url>/2021/07/10/Makefile%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="makefile"><a class="markdownIt-Anchor" href="#makefile"></a> Makefile</h1>
<h4 id="功能通过makefile文件来描述源程序之间的相互关系并自动维护编译工作"><a class="markdownIt-Anchor" href="#功能通过makefile文件来描述源程序之间的相互关系并自动维护编译工作"></a> 功能：通过makefile文件来描述源程序之间的相互关系并自动维护编译工作。</h4>
<span id="more"></span>
<ol>
<li>
<p>Makefile的变量：</p>
<ol>
<li>
<p>自定义变量：<strong>字符串(变量名):=字符串(变量值)</strong>，可通过$(变量名)替代所有的变量值。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#未使用自定义变量</span></span><br><span class="line"><span class="section">main:main.c</span></span><br><span class="line">	gcc main.c -o main</span><br><span class="line">----------------------------</span><br><span class="line"><span class="comment">#使用自定义变量</span></span><br><span class="line">target:=main</span><br><span class="line">src:=main.c</span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(src)</span></span><br><span class="line">	gcc <span class="variable">$(src)</span> -o <span class="variable">$(target)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>自动变量：随规则的变化，同一个变量名对应不同的变量值</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>$@</td>
<td>目标文件</td>
</tr>
<tr>
<td>$&lt;</td>
<td>第一个依赖文件</td>
</tr>
<tr>
<td>$^</td>
<td>所有的依赖文件，以空格分隔</td>
</tr>
<tr>
<td>$?</td>
<td>日期新于目标文件的所有相关文件列表，逗号分隔</td>
</tr>
<tr>
<td>$(@D)</td>
<td>目标文件的目录名部分</td>
</tr>
<tr>
<td>$(@F)</td>
<td>目标文件的文件名部分</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>预定义的变量：有预定义的变量，可以手动其修改含义</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>含义</th>
<th>变量值</th>
</tr>
</thead>
<tbody>
<tr>
<td>AR</td>
<td>打包库文件</td>
<td>ar</td>
</tr>
<tr>
<td>AS</td>
<td>汇编程序</td>
<td>as</td>
</tr>
<tr>
<td>CC</td>
<td>C编译器</td>
<td>cc</td>
</tr>
<tr>
<td>CPP</td>
<td>CPP编译器</td>
<td>$(CC) -E</td>
</tr>
<tr>
<td>CXX</td>
<td>C++编译器</td>
<td>g++</td>
</tr>
<tr>
<td>RM</td>
<td>删除</td>
<td>rm -f</td>
</tr>
</tbody>
</table>
</li>
</ol>
</li>
<li>
<p>wildcard：从文件系统中提取文件名(按照通配符规则)</p>
<p>subst/patsubst：文本替换/按格式文本替换</p>
   <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">srcs:=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span> <span class="comment">#srcs为目录下所有.c文件</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">var:=<span class="string">&quot;How are you&quot;</span></span><br><span class="line">newvar:=<span class="variable">$(<span class="built_in">patsubst</span> you,me,<span class="variable">$(var)</span>)</span> <span class="comment">#将var中所有的you替换成me</span></span><br><span class="line">-----------------------------------------</span><br><span class="line">srcs:=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span> </span><br><span class="line">objs:=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(srcs)</span>)</span> <span class="comment">#将srcs中所有的.c文件替换成.o文件</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>%<strong>匹配字符：从上一个规则的</strong>依赖条件</strong>中按照匹配格式匹配内容，每次匹配成功就生成一个规则，<strong>%<strong>表示匹配得到的内容。(在变量引用时使用</strong>%</strong>)</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">srcs:$(wildcard *.c) </span></span><br><span class="line"><span class="section">objs:$(patsubst %.c,%,<span class="variable">$(srcs)</span>) #匹配srcs中所有的.c文件替换成.o文件</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>for循环：</p>
   <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">srcs:=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">exes:=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%,<span class="variable">$(srcs)</span>)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    for i in <span class="variable">$(exes)</span>; do <span class="variable">$(CC)</span> $$i.c -o $$i; done <span class="comment">#$$i代表$(exes)中的内容</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>伪目标：以不存在的文件作为命令的目标(每次make都会执行)，常用<code>.PHONY</code>来区分伪目标方便阅读。</p>
</li>
<li>
<p>增量编译：</p>
   <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC:=gcc                                                                        </span><br><span class="line">srcs:=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">objs:=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(srcs)</span>)</span></span><br><span class="line">final:=main</span><br><span class="line"><span class="section">all:<span class="variable">$(final)</span></span></span><br><span class="line"><span class="variable">$(final)</span>:<span class="variable">$(objs)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:rebuild clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$(objs)</span> <span class="variable">$(final)</span></span><br><span class="line"><span class="section">rebuild:clean all </span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编译所有.c文件得到可执行文件</p>
   <figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC:=gcc                                                                        </span><br><span class="line">srcs:=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">exes:=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%,<span class="variable">$(srcs)</span>)</span></span><br><span class="line"><span class="section">all:<span class="variable">$(exes)</span></span></span><br><span class="line"><span class="section">%:%.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:rebuild clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$(exes)</span></span><br><span class="line"><span class="section">rebuild:clean all</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++基础整理</title>
    <url>/2021/06/29/C++%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="c语言学习整理"><a class="markdownIt-Anchor" href="#c语言学习整理"></a> C语言学习整理</h1>
<ol>
<li><strong>Linux进程地址空间图</strong></li>
</ol>
<img src="/images/进程地址空间.png" alt="img 进程地址空间" style="zoom: 80%;">
<span id="more"></span>
<ol start="2">
<li><strong>编译过程</strong></li>
</ol>
<img src="/images/编译过程.png" alt="img 进程地址空间" style="zoom: 80%;">
<ol start="3">
<li>
<p>变量是有名字的内存空间，其内存空间由数据类型决定大小和解释方式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1B = 8bit</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">int</span>) = <span class="number">4B</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">char</span>) = <span class="number">1B</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">long</span>) = <span class="number">4B</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">short</span>) = <span class="number">2B</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">float</span>) = <span class="number">4B</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">double</span>) = <span class="number">8B</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">void</span> *) = <span class="number">8B</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) = <span class="number">8B</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不同进制数的输出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//十进制输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;123 = %d\n&quot;</span>, <span class="number">123</span>);	</span><br><span class="line">    <span class="comment">//八进制输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0123 = %d\n&quot;</span>, <span class="number">0123</span>);	</span><br><span class="line">    <span class="comment">//十六进制输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x123 = %d\n&quot;</span>, <span class="number">0x123</span>);	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">123 = 123</span></span><br><span class="line"><span class="comment">0123 = 83</span></span><br><span class="line"><span class="comment">0x123 = 291</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>x进制 -&gt; 10进制：<br>
<img src="/images/x进制转10进制.png" alt="img x进制转10进制"><br>
2进制 -&gt; 8进制：每三位为一组</p>
<p>2进制 -&gt; 16进制：每四位为一组</p>
<p><strong>10进制 -&gt; 2进制</strong>：<a href="https://baike.baidu.com/item/%E9%99%A4k%E5%8F%96%E4%BD%99%E6%B3%95/19385576?fr=aladdin">除2取余法</a></p>
</li>
<li>
<p>内存中一般用<strong>小端存储</strong><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>法存储数据，int占据4个字节，a的地址是addr_a，b的地址是addr_b，根据以下代码说明变量a和b的真值、机器数和内存布局（每个字节的内容）分别如何？还有一种<strong>大端存储</strong><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ... //</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">-1234</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2345</span>;</span><br><span class="line"><span class="comment">// ... //</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>变量a</th>
<th>变量b</th>
</tr>
</thead>
<tbody>
<tr>
<td>真值</td>
<td>-1234</td>
<td>2345</td>
</tr>
<tr>
<td>机器数</td>
<td>FF FF FB 2E</td>
<td>00 00 09 29</td>
</tr>
<tr>
<td>内存布局</td>
<td>2E FB FF FF</td>
<td>29 09 00 00</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a href="https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613?fr=aladdin">补码</a>：有符号整型在计算机中采取补码的编码方式，通过给一个数补上一个周期，把减法变成加法。</p>
<ul>
<li>
<p>正整数：正整数的补码与原码相同。</p>
</li>
<li>
<p>负整数：负整数的补码是将其除<strong>符号位</strong><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>以外，其余所有位取反后加1。</p>
</li>
<li>
<p>0：0的补码是唯一表示的。</p>
</li>
</ul>
</li>
<li>
<p>根据机器数的大小比较真值的大小</p>
<ol>
<li>符号不同，正数 &gt; 负数</li>
<li>符号相同，机器数越大，真值越大</li>
<li>
<ul>
<li>最大负整数：1,111 1111 … = -1</li>
<li>最小负整数：1,000 0000 … = -2^(n-1)</li>
<li>最大正整数：0,111 1111 … = 2^(n-1) - 1</li>
<li>可表示的范围：-2^(n-1) ~ 2^(n-1) - 1</li>
</ul>
</li>
</ol>
</li>
<li>
<p>机器数相同，真值不一定相同，真值由解释方式决定。</p>
</li>
<li>
<p>两个有符号数的加法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">机器数1 + 机器数2 = 机器数3 -&gt; (用补码方式解释) 真值(可能会溢出)</span><br><span class="line"></span><br><span class="line">例题：给出两个数据-123和12，如果采用原码方式，如何执行加法运算；如果是补码方式，如何执行加法运算？说明在原码加法和补码加法中，分别在哪些步骤中使用了加法器、减法器和大小比较器。</span><br><span class="line"></span><br><span class="line">解：-123和12</span><br><span class="line">原码加法:</span><br><span class="line">	-123 -&gt; 1,111 1011</span><br><span class="line">	12   -&gt; 0,000 1100</span><br><span class="line">	不带符号位参与运算，判断两数绝对值，用绝对值大的减去绝对值小的，符号位与绝对值大的相同。(大小比较器)</span><br><span class="line">	111 1011 - 000 1100 = 110 0111 -&gt; 1,110 1111(减法器)</span><br><span class="line">补码加法:</span><br><span class="line">	-123 -&gt; 1,000 0101</span><br><span class="line">	12   -&gt; 0,000 1100</span><br><span class="line">	负数的补码为符号位不变，原码取反+1，带符号位参与加法运算。负数结果数值位取反+1。</span><br><span class="line">	1,000 0101 + 0,000 1100 = 1,001 0001 -&gt; 1,110 1111(加法器)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>数据的高字节存储在高地址中，数据的低字节存储在低地址中 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>数据的高字节存储在低地址中，数据的低字节存储在高地址中 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>取最高位为符号位 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown</title>
    <url>/2021/06/28/Markdown%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="markdown语法学习"><a class="markdownIt-Anchor" href="#markdown语法学习"></a> Markdown语法学习</h1>
<span id="more"></span>
<p><a href="https://www.runoob.com/markdown/md-link.html">学自菜鸟</a></p>
<ol>
<li>用=和-标记一二级标题</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">我是一级标题</span></span><br><span class="line"><span class="section">=================</span></span><br><span class="line"></span><br><span class="line"><span class="section">我是二级标题</span></span><br><span class="line"><span class="section">-----------------</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>用#标记标题(共6级)</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>换行：<strong>两个空格 + 回车</strong></p>
</li>
<li>
<p>字体加粗or斜体</p>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span></span><br><span class="line"><span class="strong">**粗体**</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体<span class="strong">**<span class="emphasis">*</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong">_斜体_</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong"><span class="strong">__粗体__</span></span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong"><span class="strong">__<span class="emphasis">_粗斜体<span class="strong">__<span class="emphasis">_</span></span></span></span></span></span></span></span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>分割线：可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> <span class="emphasis">* *</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> - -</span><br><span class="line"></span><br><span class="line"><span class="emphasis">_ _</span> <span class="emphasis">_</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li><s>删除线</s>：文字两端加~~</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure>
<ol start="7">
<li><u>下划线</u>：使用HTML中的<code>&lt;u&gt;</code>标签实现</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线<span class="xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ol start="8">
<li><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[^脚注]</span><br></pre></td></tr></table></figure>
<ol start="9">
<li>
<p>无序列表：用(*)(+)(-)后加一个空格表示</p>
</li>
<li>
<p>有序列表：用数字加上.再加一个空格表示</p>
</li>
<li>
<p>Markdown区块：段落开头使用<code>&gt;</code>符号，后面跟一个空格(可以嵌套)</p>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 区块</span></span><br><span class="line"><span class="quote">&gt; &gt; 嵌套</span></span><br></pre></td></tr></table></figure>
<ol start="12">
<li>Markdown链接：</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">链接名</span>](<span class="link">链接地址</span>)</span><br><span class="line">或者</span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure>
<ol start="13">
<li>Markdown图片：</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">name 属性文本</span>](<span class="link">图片地址 &quot;可选标题&quot;</span>)</span><br><span class="line"></span><br><span class="line">可以用<span class="xml"><span class="tag">&lt;<span class="name">img</span>&gt;</span></span>标签指定高度和宽度：<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片地址&quot;</span> <span class="attr">width</span> = <span class="string">&quot;xx%&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ol start="14">
<li>转义：</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">使用\能够正常显示特殊字符，如：</span><br><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line"><span class="bullet">*</span>   星号</span><br><span class="line"><span class="emphasis">_   下划线</span></span><br><span class="line"><span class="emphasis">&#123;&#125;  花括号</span></span><br><span class="line"><span class="emphasis">[]  方括号</span></span><br><span class="line"><span class="emphasis">()  小括号</span></span><br><span class="line"><span class="emphasis">#   井字号</span></span><br><span class="line"><span class="emphasis">+   加号</span></span><br><span class="line"><span class="emphasis">-   减号</span></span><br><span class="line"><span class="emphasis">.   英文句点</span></span><br><span class="line"><span class="emphasis">!   感叹号</span></span><br></pre></td></tr></table></figure>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>要脚注的文字 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信方式(1)-管道</title>
    <url>/2021/07/13/%E7%AE%A1%E9%81%93/</url>
    <content><![CDATA[<h1 id="进程间通信方式1-管道"><a class="markdownIt-Anchor" href="#进程间通信方式1-管道"></a> 进程间通信方式(1)-管道</h1>
<span id="more"></span>
<h2 id="无名管道"><a class="markdownIt-Anchor" href="#无名管道"></a> 无名管道</h2>
<ol>
<li>创建：使用<code>int pipe(int pipe_fd[2])</code>函数创建。
<ul>
<li>返回值：成功返回0，失败返回1。</li>
<li>参数是一个数组，保存的是管道两端的文件描述符，pipe_fd[1]是写端，pipe_fd[0]是读端。</li>
</ul>
</li>
<li>特点：
<ul>
<li>无名管道只能在有亲缘关系的进程间进行通信；例如父子，兄弟进程。</li>
<li>无名管道是半双工的，想要实现全双工需要建立两条无名管道。</li>
<li>依赖于文件系统，生命周期随着进程的结束而结束。</li>
<li>管道是基于字节流来通信的，数据与数据之间没有边界，多次写管道的话数据是粘在一起的。</li>
<li>管道关闭读端，然后写管道的话，程序会收到系统发送的SIGPIPE信号，中止程序，进程的退出码是141。shell中输入<code>echo $?</code>可以查看上次程序退出码，退出码大于128的进程都是呗信号打断的。</li>
<li>管道关闭写端，用read读取管道，read变成非阻塞状态，并返回0；</li>
</ul>
</li>
</ol>
<h2 id="有名管道"><a class="markdownIt-Anchor" href="#有名管道"></a> 有名管道</h2>
<ol>
<li>
<p>创建：使用<code>int mkfifo(const char *pathname, mod_t mode)</code>函数创建。</p>
<ul>
<li>返回值：成功返回0，失败返回-1。</li>
<li>参数1：管道名。</li>
<li>参数2：有名管道权限。</li>
</ul>
</li>
<li>
<p>特点：</p>
<ul>
<li>在没有亲缘关系之间的进程间进行通信。</li>
<li>是一种特殊类型的文件，不会随着进程的结束而消失。</li>
</ul>
</li>
<li>
<p>删除有名管道：使用<code>int unlink(const char *pathname)</code>函数删除。</p>
<ul>
<li>
<p>返回值：成功则返回0, 失败返回-1。</p>
</li>
<li>
<p>参数：管道/文件名。</p>
</li>
<li>
<p>不仅可以删除有名管道文件，还可以删除普通的文件。</p>
</li>
<li>
<p>实质是删除文件的连接数，当该文件的连接数为0时，才真正的删除管道/文件。</p>
</li>
</ul>
</li>
</ol>
<h2 id="标准流管道用的少"><a class="markdownIt-Anchor" href="#标准流管道用的少"></a> 标准流管道（用的少）</h2>
<ol>
<li>
<p>创建：使用<code>FILE *popen(const char *cmd, const char *type)</code>函数创建。</p>
<ul>
<li>
<p>返回值：成功返回标准I/O流，失败返回NULL。</p>
</li>
<li>
<p>参数1：启动另外一个进程。</p>
</li>
<li>
<p>参数2：打开的方式。</p>
</li>
</ul>
</li>
<li>
<p>特点：popen其实就是对管道的操作进行封装。</p>
<ol>
<li>创建一条管道。</li>
<li>fork一个子进程。</li>
<li>在父进程中关闭不需要使用的文件描述符。</li>
<li>执行exec函数族的调用。</li>
<li>执行函数中所指定的命令。</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL整理</title>
    <url>/2021/07/15/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h1>
<ol>
<li>
<p>数据库是什么？</p>
<p>数据库是一个实体，是保存和管理数据的“仓库”。</p>
</li>
<li>
<p>为什么要用数据库？</p>
<p>数据库是数据管理的技术和方法，它能更合适的组织数据，更方便的维护数据，更严密的控制数据，更有效的利用数据。</p>
</li>
</ol>
<span id="more"></span>
<h1 id="安装mysql数据库ubuntu-1804-lts"><a class="markdownIt-Anchor" href="#安装mysql数据库ubuntu-1804-lts"></a> 安装MySQL数据库（Ubuntu 18.04 LTS）</h1>
<ol>
<li>
<p>从Ubuntu仓库中安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install mysql-server mysql-client</span><br><span class="line"><span class="comment">#客户端依赖包</span></span><br><span class="line">$ sudo apt-get install libmysqlclient-dev</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>初始化配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo mysql_secure_installation</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>检查MySQL的服务状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl status mysql.service</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">$ sudo service mysql status</span><br></pre></td></tr></table></figure>
<p>Active: <font color="green">active (running)</font> 表示运行成功</p>
</li>
</ol>
<h1 id="mysql常用的数据类型"><a class="markdownIt-Anchor" href="#mysql常用的数据类型"></a> MySQL常用的数据类型</h1>
<img src="/images/MySQL常用数据类型.png" alt="img MySQL常用数据类型">
<h1 id="mysql使用远程登录的配置修改"><a class="markdownIt-Anchor" href="#mysql使用远程登录的配置修改"></a> MySQL使用远程登录的配置修改</h1>
<ol>
<li>
<p>进入配置文件修改相应配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注释掉<code>bind-address = 127.0.0.1</code>(前面加#号)，保存并退出</p>
</li>
<li>
<p>进入数据库执行授权命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># %表示任意ip可登录</span><br><span class="line">mysql&gt; grant all on *.* to &lt;数据库用户名&gt;@&#x27;%&#x27; identified by &#x27;&lt;用户密码&gt;&#x27; with grant option;</span><br><span class="line"></span><br><span class="line"># 刷新权限</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line"></span><br><span class="line"># 退出MySQL</span><br><span class="line">mysql&gt; exit;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重启MySQL</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart mysql</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="mysql部分操作"><a class="markdownIt-Anchor" href="#mysql部分操作"></a> MySQL部分操作</h1>
<ol>
<li>
<p>进入数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo mysql -u root -p</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>退出数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1</span><br><span class="line">mysql&gt; quit;</span><br><span class="line">#2</span><br><span class="line">mysql&gt; exit;</span><br><span class="line">#3</span><br><span class="line">CTRL-D</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>显示所有数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create database school;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改数据库的字符集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter database school character set utf8;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; drop database school;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; use school;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table student (</span><br><span class="line">    -&gt; id int,</span><br><span class="line">    -&gt; name char(20),</span><br><span class="line">    -&gt; age int,</span><br><span class="line">    -&gt; score float);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; drop table student;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查看表结构信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show create table student;</span><br><span class="line">#或者</span><br><span class="line">mysql&gt; desc student;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查看当前数据库中所有表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改表，表的字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#change可以改变列名，同样可以改变类型， 但是不能单独去修改类型， modify只可以修改类型，不能修改名字</span><br><span class="line">mysql&gt; alter table student modify score int;</span><br><span class="line">mysql&gt; alter table student change name mingzi int;</span><br><span class="line">mysql&gt; alter table student change mingzi name varchar(20);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改表名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; rename table student to stu;</span><br><span class="line">mysql&gt; alter table stu rename to student;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在表中插入字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table student add english float;</span><br><span class="line">mysql&gt; alter table student add chinese float first;# 插入到第一列</span><br><span class="line">mysql&gt; alter table student add cs float after math;# 插入到math后面</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除表中的字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table student drop cs;</span><br><span class="line">mysql&gt; alter table student drop english;</span><br><span class="line">mysql&gt; alter table student drop chinese;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>向表中插入数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into student (id, name, age, math) </span><br><span class="line">    -&gt; values (1, &#x27;zhangsan&#x27;, 18, 80);</span><br><span class="line">#也可以向表中插入部分数据</span><br><span class="line">mysql&gt; insert into student (id, name, math) </span><br><span class="line">    -&gt; values (2, &#x27;libowen&#x27;, 100);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询表中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+------+----------+------+------+</span><br><span class="line">| id   | name     | age  | math |</span><br><span class="line">+------+----------+------+------+</span><br><span class="line">|    1 | zhangsan |   18 |   80 |</span><br><span class="line">|    2 | libowen  | NULL |  100 |</span><br><span class="line">+------+----------+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不写列名插入数据，必须把所有值按顺序赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into student values (3, &#x27;lile&#x27;, 24, 59);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>快速插入多条数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into student values (4, &#x27;xienan&#x27;, 18, 90), (5, &#x27;gougou&#x27;, 23, 5);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改表中元素值，更新数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table student add art float;</span><br><span class="line">mysql&gt; update student set art = 100 where id = 4;</span><br><span class="line">mysql&gt; update student set age = 23 where id = 2;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>一次更新多个数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; update student set age = 3, math = 10, art = 20 where name = &#x27;gougou&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除表中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; delete from student where name = &#x27;zhangsan&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以对表中插入空值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into student (id) values (NULL);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除表中的空值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; delete from student where id is NULL;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询表中单个数据的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select name from student;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询表中部分数据的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select name, art from student;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对查询结果去重</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; update student set age = 24 where name = &#x27;gougou&#x27;;</span><br><span class="line">mysql&gt; select distinct age from student;</span><br><span class="line">+------+</span><br><span class="line">| age  |</span><br><span class="line">+------+</span><br><span class="line">|   23 |</span><br><span class="line">|   24 |</span><br><span class="line">|   18 |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对查询结果做表达式运算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select name, math + 20 from student;</span><br><span class="line">+---------+-----------+</span><br><span class="line">| name    | math + 20 |</span><br><span class="line">+---------+-----------+</span><br><span class="line">| libowen |       120 |</span><br><span class="line">| lile    |        79 |</span><br><span class="line">| xienan  |       110 |</span><br><span class="line">| gougou  |        30 |</span><br><span class="line">+---------+-----------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对表达式取别名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select name, math + 20 as math2 from student;</span><br><span class="line">+---------+-------+</span><br><span class="line">| name    | math2 |</span><br><span class="line">+---------+-------+</span><br><span class="line">| libowen |   120 |</span><br><span class="line">| lile    |    79 |</span><br><span class="line">| xienan  |   110 |</span><br><span class="line">| gougou  |    30 |</span><br><span class="line">+---------+-------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询某些特定的列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student where age &gt; 18;</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">| id   | name    | age  | math | art  |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">|    2 | libowen |   23 |  100 | NULL |</span><br><span class="line">|    3 | lile    |   24 |   59 | NULL |</span><br><span class="line">|    5 | gougou  |   24 |   10 |   20 |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from student where age &lt; 24;</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">| id   | name    | age  | math | art  |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">|    2 | libowen |   23 |  100 | NULL |</span><br><span class="line">|    4 | xienan  |   18 |   90 |  100 |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from student where age != 18;</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">| id   | name    | age  | math | art  |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">|    2 | libowen |   23 |  100 | NULL |</span><br><span class="line">|    3 | lile    |   24 |   59 | NULL |</span><br><span class="line">|    5 | gougou  |   24 |   10 |   20 |</span><br><span class="line">+------+---------+------+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询某范围的数据between …  and … 查询范围是闭区间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student where math between 60 and 100;</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">| id   | name    | age  | math | art  |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">|    2 | libowen |   23 |  100 | NULL |</span><br><span class="line">|    4 | xienan  |   18 |   90 |  100 |</span><br><span class="line">+------+---------+------+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询集合中的数据<code>in（set）</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student where age in (18, 24);</span><br><span class="line">+------+--------+------+------+------+</span><br><span class="line">| id   | name   | age  | math | art  |</span><br><span class="line">+------+--------+------+------+------+</span><br><span class="line">|    3 | lile   |   24 |   59 | NULL |</span><br><span class="line">|    4 | xienan |   18 |   90 |  100 |</span><br><span class="line">|    5 | gougou |   24 |   10 |   20 |</span><br><span class="line">+------+--------+------+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>模糊查询<code>like</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student where name like &#x27;%nan&#x27;;</span><br><span class="line">+------+--------+------+------+------+</span><br><span class="line">| id   | name   | age  | math | art  |</span><br><span class="line">+------+--------+------+------+------+</span><br><span class="line">|    4 | xienan |   18 |   90 |  100 |</span><br><span class="line">+------+--------+------+------+------+</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from student where name like &#x27;%l_&#x27;;</span><br><span class="line">+------+------+------+------+------+</span><br><span class="line">| id   | name | age  | math | art  |</span><br><span class="line">+------+------+------+------+------+</span><br><span class="line">|    3 | lile |   24 |   59 | NULL |</span><br><span class="line">+------+------+------+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询多个条件同时成立<code>and</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student where name = &#x27;gougou&#x27; and age = 24;</span><br><span class="line">+------+--------+------+------+------+</span><br><span class="line">| id   | name   | age  | math | art  |</span><br><span class="line">+------+--------+------+------+------+</span><br><span class="line">|    5 | gougou |   24 |   10 |   20 |</span><br><span class="line">+------+--------+------+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询多个条件任一成立<code>or</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student where name = &#x27;gougou&#x27; or age = 23;</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">| id   | name    | age  | math | art  |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">|    2 | libowen |   23 |  100 | NULL |</span><br><span class="line">|    5 | gougou  |   24 |   10 |   20 |</span><br><span class="line">+------+---------+------+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询条件不成立的项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student where not (name = &#x27;xienan&#x27;);</span><br><span class="line">mysql&gt; select * from student where not name = &#x27;xienan&#x27;;</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">| id   | name    | age  | math | art  |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">|    2 | libowen |   23 |  100 | NULL |</span><br><span class="line">|    3 | lile    |   24 |   59 | NULL |</span><br><span class="line">|    5 | gougou  |   24 |   10 |   20 |</span><br><span class="line">+------+---------+------+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对查询结果排序（默认升序）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student order by age;</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">| id   | name    | age  | math | art  |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">|    4 | xienan  |   18 |   90 |  100 |</span><br><span class="line">|    2 | libowen |   23 |  100 | NULL |</span><br><span class="line">|    3 | lile    |   24 |   59 | NULL |</span><br><span class="line">|    5 | gougou  |   24 |   10 |   20 |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">#逆序</span><br><span class="line">mysql&gt; select * from student order by age desc;</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">| id   | name    | age  | math | art  |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">|    3 | lile    |   24 |   59 | NULL |</span><br><span class="line">|    5 | gougou  |   24 |   10 |   20 |</span><br><span class="line">|    2 | libowen |   23 |  100 | NULL |</span><br><span class="line">|    4 | xienan  |   18 |   90 |  100 |</span><br><span class="line">+------+---------+------+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>显示固定数量的数据<code>limit</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student order by age desc limit 3;</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">| id   | name    | age  | math | art  |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">|    3 | lile    |   24 |   59 | NULL |</span><br><span class="line">|    5 | gougou  |   24 |   10 |   20 |</span><br><span class="line">|    2 | libowen |   23 |  100 | NULL |</span><br><span class="line">+------+---------+------+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对查询结果进行偏移<code>offset</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student order by age desc limit 1 offset 2;</span><br><span class="line">#像后偏移了两个数据</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">| id   | name    | age  | math | art  |</span><br><span class="line">+------+---------+------+------+------+</span><br><span class="line">|    2 | libowen |   23 |  100 | NULL |</span><br><span class="line">+------+---------+------+------+------+</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>数据的完整性：</p>
<ol>
<li>实体完整性：通过主键保证插入的数据（一行）是表中唯一的实体，防止重复插入数据，浪费空间。</li>
<li>域完整性：保证列的数据类型和约束。</li>
<li>参照完整性：保证一个表的外键与另外 一个表的主键相关联，要求关系中不允许引用不存在的实体。</li>
</ol>
<p>数据完整性只能尽量的保证插入的数据是正确的，不能百分百保证数据的正确。</p>
<p>多表设计：</p>
<ol>
<li>一对多：避免数据的冗余，节约空间。</li>
<li>多对多：避免数据的荣誉，节约空间。</li>
<li>一对一：为了方便扩展，可以扩展成一对多，也可以扩展成多对多。</li>
</ol>
</blockquote>
<ol start="39">
<li>
<p>创建新表，设置主键，主键不能为NULL，不能为重复值，将主键设置为自动增长</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table teacher (</span><br><span class="line">    # auto_increment 实现自动增长功能</span><br><span class="line">    -&gt; id int auto_increment,</span><br><span class="line">    -&gt; name varchar(20),</span><br><span class="line">    -&gt; age int,</span><br><span class="line">    # 设置id为主键</span><br><span class="line">    -&gt; primary key(id)</span><br><span class="line">    -&gt; );</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>某字段设置为自动增长后，不赋值该字段，那么它会接着之前表中已有最大的值继续增加。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into teacher (name, age) values (&#x27;ma&#x27;, 28), (&#x27;liao&#x27;, 30), (&#x27;wang&#x27;, 31);</span><br><span class="line">mysql&gt; select * from teacher;</span><br><span class="line">+----+------+------+</span><br><span class="line">| id | name | age  |</span><br><span class="line">+----+------+------+</span><br><span class="line">|  1 | ma   |   28 |</span><br><span class="line">|  2 | liao |   30 |</span><br><span class="line">|  3 | wang |   31 |</span><br><span class="line">+----+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>创建新表，并设置外键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table project (</span><br><span class="line">    -&gt; id int auto_increment primary key,</span><br><span class="line">    -&gt; name varchar(20),</span><br><span class="line">    -&gt; teacher_id int,</span><br><span class="line">    -&gt; foreign key(teacher_id) references teacher(id)</span><br><span class="line">	-&gt; );</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>复制表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#只复制表数据，不复制表结构</span><br><span class="line">mysql&gt; create table teacher1 select * from teacher;</span><br><span class="line">#只复制表结构，不复制表中数据</span><br><span class="line">mysql&gt; create table teacher2 like teacher;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对一个没有设置主键的表设置主键</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> student modify id <span class="type">int</span> <span class="keyword">primary</span> key;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对一个没有外键的表设置外键，设置外键的时候， 关联的必须是另一个表的主键，而且类型需要相同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table student add teacher_id int;</span><br><span class="line">mysql&gt; alter table student add foreign key(teacher_id) references teacher(id); </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>主动设置外键名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table student add CONSTRAINT student_foreign_key FOREIGN KEY(teacher_id) REFERENCES teacher(id);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除外键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table student drop FOREIGN KEY teacher_id;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查看当前工作数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select database();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除主键，如果有外键关联该表的主键，是不能删除该表的主键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table student drop primary key;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>交叉查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student cross join teacher;</span><br><span class="line">+----+---------+------+------+------+------------+----+------+------+</span><br><span class="line">| id | name    | age  | math | art  | teacher_id | id | name | age  |</span><br><span class="line">+----+---------+------+------+------+------------+----+------+------+</span><br><span class="line">|  2 | libowen |   23 |  100 | NULL |       NULL |  1 | ma   |   28 |</span><br><span class="line">|  2 | libowen |   23 |  100 | NULL |       NULL |  2 | liao |   30 |</span><br><span class="line">|  2 | libowen |   23 |  100 | NULL |       NULL |  3 | wang |   31 |</span><br><span class="line">|  3 | lile    |   24 |   59 | NULL |       NULL |  1 | ma   |   28 |</span><br><span class="line">|  3 | lile    |   24 |   59 | NULL |       NULL |  2 | liao |   30 |</span><br><span class="line">|  3 | lile    |   24 |   59 | NULL |       NULL |  3 | wang |   31 |</span><br><span class="line">|  4 | xienan  |   18 |   90 |  100 |       NULL |  1 | ma   |   28 |</span><br><span class="line">|  4 | xienan  |   18 |   90 |  100 |       NULL |  2 | liao |   30 |</span><br><span class="line">|  4 | xienan  |   18 |   90 |  100 |       NULL |  3 | wang |   31 |</span><br><span class="line">|  5 | gougou  |   24 |   10 |   20 |       NULL |  1 | ma   |   28 |</span><br><span class="line">|  5 | gougou  |   24 |   10 |   20 |       NULL |  2 | liao |   30 |</span><br><span class="line">|  5 | gougou  |   24 |   10 |   20 |       NULL |  3 | wang |   31 |</span><br><span class="line">+----+---------+------+------+------+------------+----+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>内连接查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student cross join teacher on student.id = teacher.id;</span><br><span class="line">+----+---------+------+------+------+------------+----+------+------+</span><br><span class="line">| id | name    | age  | math | art  | teacher_id | id | name | age  |</span><br><span class="line">+----+---------+------+------+------+------------+----+------+------+</span><br><span class="line">|  2 | libowen |   23 |  100 | NULL |       NULL |  2 | liao |   30 |</span><br><span class="line">|  3 | lile    |   24 |   59 | NULL |       NULL |  3 | wang |   31 |</span><br><span class="line">+----+---------+------+------+------+------------+----+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>隐式内连接不加inner join</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from teacher, student where student.id = teacher.stu_id;</span><br><span class="line">+----+------+--------+--------+----+------+------+-------+</span><br><span class="line">| id | name | pro_id | stu_id | id | name | age  | score |</span><br><span class="line">+----+------+--------+--------+----+------+------+-------+</span><br><span class="line">|  1 | ma   |      1 |      1 |  1 | xx   |   18 |    88 |</span><br><span class="line">+----+------+--------+--------+----+------+------+-------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以对查询的表名起别名as</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from teacher as t inner join student as s on s.id = t.stu_id;</span><br><span class="line">+----+------+--------+--------+----+------+------+-------+</span><br><span class="line">| id | name | pro_id | stu_id | id | name | age  | score |</span><br><span class="line">+----+------+--------+--------+----+------+------+-------+</span><br><span class="line">|  1 | ma   |      1 |      1 |  1 | xx   |   18 |    88 |</span><br><span class="line">+----+------+--------+--------+----+------+------+-------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>左外连接（以左表为基准）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student left outer join teacher on student.id = teacher.stu_id;</span><br><span class="line">+----+------+------+-------+------+------+--------+--------+</span><br><span class="line">| id | name | age  | score | id   | name | pro_id | stu_id |</span><br><span class="line">+----+------+------+-------+------+------+--------+--------+</span><br><span class="line">|  1 | xx   |   18 |    88 |    1 | ma   |      1 |      1 |</span><br><span class="line">+----+------+------+-------+------+------+--------+--------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>右外连接（以右表为基准）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student right outer join teacher on student.id = teacher.stu_id;</span><br><span class="line">+------+------+------+-------+----+------+--------+--------+</span><br><span class="line">| id   | name | age  | score | id | name | pro_id | stu_id |</span><br><span class="line">+------+------+------+-------+----+------+--------+--------+</span><br><span class="line">|    1 | xx   |   18 |    88 |  1 | ma   |      1 |      1 |</span><br><span class="line">+------+------+------+-------+----+------+--------+--------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>子查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student where id = (select id from student where name like &#x27;%x&#x27;);</span><br><span class="line">+----+------+------+-------+</span><br><span class="line">| id | name | age  | score |</span><br><span class="line">+----+------+------+-------+</span><br><span class="line">|  1 | xx   |   18 |    88 |</span><br><span class="line">+----+------+------+-------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>联合查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select score from student where id &gt; 2 union select score from student where score &lt; 90;</span><br><span class="line">+-------+</span><br><span class="line">| score |</span><br><span class="line">+-------+</span><br><span class="line">|    68 |</span><br><span class="line">|    88 |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对联合查询结果不去重union all</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select score from student where id &gt; 2 union all select score from student where score &lt; 90;   </span><br><span class="line">+-------+</span><br><span class="line">| score |</span><br><span class="line">+-------+</span><br><span class="line">|    68 |</span><br><span class="line">|    88 |</span><br><span class="line">|    68 |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>报表查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select age from student group by age;</span><br><span class="line">+------+</span><br><span class="line">| age  |</span><br><span class="line">+------+</span><br><span class="line">|   18 |</span><br><span class="line">|   20 |</span><br><span class="line">|   22 |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>统计函数和报表查询联合使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#group by后面的组要是同样的， 不然查不到</span><br><span class="line">mysql&gt; select count(age),age from student group by age;</span><br><span class="line">+------------+------+</span><br><span class="line">| count(age) | age  |</span><br><span class="line">+------------+------+</span><br><span class="line">|          1 |   18 |</span><br><span class="line">|          1 |   20 |</span><br><span class="line">|          1 |   22 |</span><br><span class="line">+------------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查询表中最大和最小的年纪</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select max(age),min(age) from student;</span><br><span class="line">+----------+----------+</span><br><span class="line">| max(age) | min(age) |</span><br><span class="line">+----------+----------+</span><br><span class="line">|       22 |       18 |</span><br><span class="line">+----------+----------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对报表查询做条件查询group by … having …</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#用insert into加了一点数据</span><br><span class="line">mysql&gt; select count(age), age from student group by age having age &lt; 25;</span><br><span class="line">+------------+------+</span><br><span class="line">| count(age) | age  |</span><br><span class="line">+------------+------+</span><br><span class="line">|          1 |    7 |</span><br><span class="line">|          1 |    8 |</span><br><span class="line">|          1 |   18 |</span><br><span class="line">|          1 |   20 |</span><br><span class="line">|          2 |   21 |</span><br><span class="line">|          1 |   22 |</span><br><span class="line">+------------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对查询出来的临时表再次查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select count(age), age from student group by age having count(age) &gt; 1;</span><br><span class="line">+------------+------+</span><br><span class="line">| count(age) | age  |</span><br><span class="line">+------------+------+</span><br><span class="line">|          2 |   21 |</span><br><span class="line">|          2 |   26 |</span><br><span class="line">+------------+------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>数据库的备份和恢复</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 备份</span></span><br><span class="line">sudo mysqldump -u root -p school &gt; school.sql</span><br><span class="line"><span class="comment"># 恢复，得先建库（create database  + 库名）</span></span><br><span class="line">sudo mysql -u root -p school &lt; school.sql</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编译数据库代码需要加动态库<code>-lmysqlclient</code></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>线程</title>
    <url>/2021/07/14/%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="进程与线程的特点与区别"><a class="markdownIt-Anchor" href="#进程与线程的特点与区别"></a> 进程与线程的特点与区别</h1>
<ol>
<li>进程：资源分配的基本单位（最小单位），拥有自己独立的资源，如自己独立的数据段、代码段和堆栈段，所以在CPU进行进程切换时需要保存大量的上下文<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，需要大量的时间开销。<strong>为了减少这一时间开销，因此引入了线程。</strong>
<ul>
<li>创建：<code>fork()</code></li>
<li>退出：<code>exit()</code></li>
<li>等待：<code>wait()</code></li>
</ul>
</li>
<li>线程：CPU调度的基本单位，一个进程至少拥有一个线程。一个进程中的多个线程会共享该进程的地址空间。线程只拥有少量的栈空间。线程的缺点：不利于资源的管理和保护<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。
<ul>
<li>创建：<code>pthread_create()</code></li>
<li>退出：<code>pthread_exit()</code></li>
<li>等待：<code>pthread_join()</code></li>
</ul>
<span id="more"></span>
</li>
<li>用比喻理解两者关系：进程就好比一个学校的某一间宿舍，线程就好比该宿舍中的某个人。</li>
<li>查看进程相关信息的命令：<code>ps -elf</code></li>
<li>查看线程相关信息的命令：<code>ps -elLf</code>（查看的时核心级线程id）</li>
</ol>
<h1 id="线程的种类"><a class="markdownIt-Anchor" href="#线程的种类"></a> 线程的种类</h1>
<ol>
<li>用户级：用户自己创建的线程。</li>
<li>核心级：CPU实际运行的线程。</li>
</ol>
<h1 id="线程的一些操作"><a class="markdownIt-Anchor" href="#线程的一些操作"></a> 线程的一些操作</h1>
<ol>
<li>
<p>线程的创建：<code>int pthread_create(pthread_t *thread, const pthread_attr_t attr, void *(*start_routine)(void *), void *arg)</code></p>
<ul>
<li>
<p>返回值：成功返回0，失败返回错误码。</p>
</li>
<li>
<p>参数1：线程id。</p>
</li>
<li>
<p>参数2：线程的属性，没有特殊设置填NULL。</p>
</li>
<li>
<p>参数3：线程的处理函数，注意函数类型为void *型。</p>
</li>
<li>
<p>参数4：线程处理函数的参数。</p>
</li>
</ul>
</li>
<li>
<p>线程的等待：<code>int pthread_join(pthread_t thread, void **retval)</code></p>
<ul>
<li>返回值：成功返回0，失败返回错误码。</li>
<li>参数1：等待退出的线程id。</li>
<li>参数2：接收子线程的退出，可以接收指针类型的退出状态，也可以接收long类型的变量。</li>
</ul>
</li>
<li>
<p>线程的退出：<code>int pthread_exit(void *retval)</code></p>
<ul>
<li>返回值：使用函数的返回值作为线程的退出状态。（函数说明直译的，一般没啥用）</li>
<li>参数：指向线程thread的返回值，一般填NULL。</li>
</ul>
</li>
<li>
<p>线程id的获取：<code>pthread_t pthread_self(void)</code>，永远不会失败，成功返回线程id。</p>
</li>
<li>
<p>线程的取消：</p>
<ol>
<li>线程可以自己调用线程退出函数退出，也可以被其他线程杀掉，被其他线程杀掉的方式就叫做线程的取消。</li>
<li>被杀掉的线程可以选择自己如何处理这个信号，如：忽略、立即终止、运行到<strong>取消点</strong>后终止。</li>
<li>取消点：就是一些特殊函数：一般的阻塞性函数都是取消点，非阻塞性函数也有可能是取消点。</li>
<li>线程取消函数：<code>int pthread_cancel(pthread_t thread)</code>
<ul>
<li>返回值：成功返回0，失败返回错误码。</li>
<li>想要cancel掉的线程id。</li>
</ul>
</li>
</ol>
</li>
</ol>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>—个进程的上下文(context)包括进程的状态、有关变量和数据结构的值、机器寄存器的值和PCB以及有关程序、数据等。一个进程的执行是在进程的上下文中执行。当正在执行的进程由于某种原因要让出处理机时，系统要做进程上下文切换，以使另一个进程得以执行。当进行上下文切换时点统要首先检查是否允许做上下文切换(在有些情况下，上下文切换是不允许的，例如系统正在执行某个不允许中断的原语时)。然后，系统要保留有关被切换进程的足够信息，以便以后切换回该进程时，顺利恢复该进程的执行。在系统保留了CPU现场之后，调度程序选择一个新的处于就绪状态的进程、并装配该进程的上下文，使CPU的控制权掌握在被选中进程手中。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>线程上锁后如果崩溃了，那么资源无法得到释放，其他线程都无法继续正常执行 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2021/07/15/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h1>
<p>使用线程池的好处：</p>
<ol>
<li>降低资源的消耗，多个线程能共享同一个进程的内存空间。</li>
<li>提高响应速度，任务来时能直接响应不需要等待。</li>
<li>提高现成的可管理性，线程不能无限制创建，有数量限制。
<ul>
<li>对于IO密集型的任务：线程数量一般等于CPU核心数的二倍。</li>
<li>对于CPU密集型的任务：线程的数量一般等于CPU核心数+1。</li>
</ul>
</li>
</ol>
<span id="more"></span>
<h2 id="程序运行流程"><a class="markdownIt-Anchor" href="#程序运行流程"></a> 程序运行流程</h2>
<ol>
<li>主线程：
<ol>
<li>创建线程池，初始化。</li>
<li>线程池启动，创建制定数量的线程。</li>
<li>服务器绑定tcp通信套接字。</li>
<li>创建epoll，并将需要监听的tcp通信套接字放入epoll。</li>
<li><code>accept()</code>函数等待客户端连接。</li>
<li>接收客户端连接，创建任务队列中的任务节点，将用于与客户端连接的通信描述符存入任务节点，再将任务节点放入任务队列，队列长度＋1。并激发所有的条件变量。</li>
<li>回到步骤5等待下一次客户端请求连接。</li>
</ol>
</li>
<li>子线程：
<ol>
<li>队列上锁，进入<code>pthread_cond_wait()</code>函数。</li>
<li>等待主线程激发。</li>
<li>子线程被激发，抢到任务队列中的任务节点，任务节点出队，队列长度－1，解锁。</li>
<li>用任务节点中的文件描述符服务客户端，服务完关闭文件描述符。</li>
<li>回到步骤1等待下一次任务。</li>
</ol>
</li>
</ol>
<h2 id="程序的退出"><a class="markdownIt-Anchor" href="#程序的退出"></a> 程序的退出</h2>
<ol>
<li>主线程：
<ol>
<li>收到退出信号，通过信号处理函数对退出管道进行写数据。</li>
<li>epoll监听到，主线程将任务队列中的退出标识位置1，并激发所有条件变量。</li>
<li>等到所有子线程退出后主线程再退出。</li>
</ol>
</li>
<li>子线程：
<ol>
<li>队列上锁，进入<code>pthread_cond_wait()</code>函数。</li>
<li>等待主线程激发。</li>
<li>子线程被激发，发现任务队列中推出标识位为1，进行线程的退出。</li>
</ol>
</li>
</ol>
<h2 id="数据结构设计"><a class="markdownIt-Anchor" href="#数据结构设计"></a> 数据结构设计</h2>
<ol>
<li>
<p>线程池结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程池结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">//线程个数</span></span><br><span class="line">    <span class="keyword">int</span> thread_num;</span><br><span class="line">    <span class="comment">//线程id数组，动态创建</span></span><br><span class="line">    <span class="keyword">pthread_t</span> *pThread_id;</span><br><span class="line">    <span class="comment">//任务队列</span></span><br><span class="line">    <span class="keyword">task_que_t</span> task_que;</span><br><span class="line">&#125;<span class="keyword">thread_pool_t</span>, *pThread_pool_t;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>任务队列结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//任务队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_que_s</span>&#123;</span></span><br><span class="line">    <span class="comment">//退出信号</span></span><br><span class="line">    <span class="keyword">short</span> exit_flag;</span><br><span class="line">    <span class="comment">//任务队列长度</span></span><br><span class="line">    <span class="keyword">int</span> que_len;</span><br><span class="line">    <span class="comment">//线程的条件变量</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> que_cond;</span><br><span class="line">    <span class="comment">//线程锁</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> que_mutex;</span><br><span class="line">    <span class="comment">//任务队列的首尾指针</span></span><br><span class="line">    pTask_node_t pHead, pTail;</span><br><span class="line">&#125;<span class="keyword">task_que_t</span>, *pTask_que_t;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>任务节点结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个任务中存储与客户端通信的文件描述符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_node_s</span>&#123;</span></span><br><span class="line">    <span class="comment">//与客户端通信的文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> client_fd;</span><br><span class="line">    <span class="comment">//下一个任务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_node_s</span> *<span class="title">pNext</span>;</span></span><br><span class="line">&#125;<span class="keyword">task_node_t</span>, *pTask_node_t;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>传输数据结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于传输数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data_len;</span><br><span class="line">    <span class="keyword">char</span> data_buf[<span class="number">1000</span>];</span><br><span class="line">&#125;<span class="keyword">train_t</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="主程序设计"><a class="markdownIt-Anchor" href="#主程序设计"></a> 主程序设计</h2>
<h3 id="mainc主程序"><a class="markdownIt-Anchor" href="#mainc主程序"></a> main.c:主程序</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../head/func.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../head/taskque.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../head/threadpoll.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> out_pipe[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main_sigfunc</span><span class="params">(<span class="keyword">int</span> signum)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sig = %d is coming\n&quot;</span>, signum);</span><br><span class="line">    write(out_pipe[<span class="number">1</span>], <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//./server_pool ip port pthread_num</span></span><br><span class="line">    ARGS_CHECK(argc, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    signal(<span class="number">10</span>, main_sigfunc);</span><br><span class="line">    pipe(out_pipe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fork())&#123;</span><br><span class="line">        <span class="comment">//主进程关闭读端</span></span><br><span class="line">        close(out_pipe[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待子进程的退出然后退出</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main out\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子进程关闭写端</span></span><br><span class="line">    close(out_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pthread_num = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">//创建进程池结构体，不是指针！</span></span><br><span class="line">    <span class="keyword">thread_pool_t</span> pool;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;pool, <span class="number">0</span>, <span class="keyword">sizeof</span>(pool));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.初始化线程池，创建pthread_num个线程空间，创建任务队列</span></span><br><span class="line">    ret = ThreadPoolInit(&amp;pool, pthread_num);</span><br><span class="line">    THREAD_ERROR_CHECK(ret, <span class="string">&quot;ThreadPoolInit&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.开启线程池，创建线程，接收任务</span></span><br><span class="line">    ret = ThreadPoolCreate(&amp;pool);</span><br><span class="line">    THREAD_ERROR_CHECK(ret, <span class="string">&quot;ThreadPoolCreate&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.创建Tcp套接字监听连接</span></span><br><span class="line">    <span class="keyword">int</span> socket_fd = <span class="number">0</span>;</span><br><span class="line">    ret = TcpInit(argv[<span class="number">1</span>], argv[<span class="number">2</span>], &amp;socket_fd);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;TcpInit&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.创建epoll，参数只要大于0就行，并将需要监听的文件描述符添加到epoll中</span></span><br><span class="line">    <span class="keyword">int</span> epoll_fd = epoll_create(<span class="number">1</span>);</span><br><span class="line">    ret = EpollAddFd(epoll_fd, socket_fd);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;EpollAddFd&quot;</span>);</span><br><span class="line">    ret = EpollAddFd(epoll_fd, out_pipe[<span class="number">0</span>]);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;EpollAddFd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//epoll结构体，存放就绪文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span>[2];</span></span><br><span class="line">    <span class="built_in">memset</span>(evs, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct epoll_event));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//-1表示无条件等待</span></span><br><span class="line">        <span class="keyword">int</span> ready_num = epoll_wait(epoll_fd, evs, <span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ready_num; ++i)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(evs[i].data.fd == out_pipe[<span class="number">0</span>])&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//修改任务队列中的退出标号为1</span></span><br><span class="line">                pthread_mutex_lock(&amp;pool.task_que.que_mutex);</span><br><span class="line">                pool.task_que.exit_flag = <span class="number">1</span>;</span><br><span class="line">                pthread_mutex_unlock(&amp;pool.task_que.que_mutex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//激发全部条件变量</span></span><br><span class="line">                ret = pthread_cond_broadcast(&amp;pool.task_que.que_cond);</span><br><span class="line">                THREAD_ERROR_CHECK(ret, <span class="string">&quot;pthread_cond_broadcast&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//等待线程退出</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pthread_num; ++j)&#123;</span><br><span class="line">                    pthread_join(pool.pThread_id[j], <span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child process exit\n&quot;</span>);</span><br><span class="line">                <span class="comment">//子进程退出</span></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(evs[i].data.fd == socket_fd)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//接收新连接的文件描述符</span></span><br><span class="line">                <span class="keyword">int</span> new_fd = accept(socket_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                ERROR_CHECK(new_fd, <span class="number">-1</span>, <span class="string">&quot;accept&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//保存文件描述符到任务节点</span></span><br><span class="line">                pTask_node_t pTask = (pTask_node_t)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">task_node_t</span>));</span><br><span class="line">                pTask-&gt;client_fd = new_fd;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//用这种方式申请的节点，不能用free释放，浪费内存空间</span></span><br><span class="line">                <span class="comment">/* //保存文件描述符到任务节点 */</span></span><br><span class="line">                <span class="comment">/* task_node_t task_node; */</span></span><br><span class="line">                <span class="comment">/* memset(&amp;task_node, 0, sizeof(task_node_t)); */</span></span><br><span class="line">                <span class="comment">/* task_node.client_fd = new_fd; */</span></span><br><span class="line">                <span class="comment">/* printf(&quot;node save fd = %d\n&quot;, task_node.client_fd); */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//加锁，互斥修改任务队列</span></span><br><span class="line">                pthread_mutex_lock(&amp;pool.task_que.que_mutex);</span><br><span class="line">                ret = InsertTaskQue(&amp;pool.task_que, pTask);</span><br><span class="line">                ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;InsertTaskQue&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//插入节点成功，激发所有条件变量</span></span><br><span class="line">                ret = pthread_cond_broadcast(&amp;pool.task_que.que_cond);</span><br><span class="line">                THREAD_ERROR_CHECK(ret, <span class="string">&quot;pthread_cond_broadcast&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//解锁</span></span><br><span class="line">                pthread_mutex_unlock(&amp;pool.task_que.que_mutex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="threadpoolc线程池相关函数"><a class="markdownIt-Anchor" href="#threadpoolc线程池相关函数"></a> ThreadPool.c：线程池相关函数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//void型的线程清理函数!</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clean_func</span><span class="params">(<span class="keyword">void</span> *p)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    pTask_que_t que = (pTask_que_t)p;</span><br><span class="line">    pthread_mutex_unlock(&amp;que-&gt;que_mutex);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_func</span><span class="params">(<span class="keyword">void</span> *p)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将传入进来的队列进行类型转换</span></span><br><span class="line">    pTask_que_t que = (pTask_que_t)p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建任务节点用取任务</span></span><br><span class="line">    pTask_node_t pTask = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取任务函数的返回值，0为失败，1为成功</span></span><br><span class="line">    <span class="keyword">int</span> get_success = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上锁互斥访问队列，如果之前上锁，则会阻塞</span></span><br><span class="line">        pthread_mutex_lock(&amp;que-&gt;que_mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清理函数紧贴要清理的资源，前面上锁了所以要在清理函数里面解锁</span></span><br><span class="line">        pthread_cleanup_push(clean_func, que);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果队列中没有节点</span></span><br><span class="line">        <span class="comment">//函数上半部做的是：1.条件变量上排队2.解锁3.睡眠等待激发</span></span><br><span class="line">        <span class="comment">//函数下半部做的是：1.被唤醒（激发）2.加锁，如果已经上锁，则阻塞至锁解锁，然后加锁3.pthread_cond_wait函数返回</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == que-&gt;que_len)&#123;</span><br><span class="line">            pthread_cond_wait(&amp;que-&gt;que_cond, &amp;que-&gt;que_mutex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//GetTaskNode取节点</span></span><br><span class="line">        get_success = GetTaskNode(que, &amp;pTask);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;que-&gt;que_mutex);</span><br><span class="line">        pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取节点成功，用文件描述符发送文件，任务完成释放节点资源，置为空指针</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == get_success)&#123;</span><br><span class="line">            TransFile(pTask-&gt;client_fd);</span><br><span class="line">            <span class="built_in">free</span>(pTask);</span><br><span class="line">            pTask = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == que-&gt;exit_flag)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;thread out\n&quot;</span>);</span><br><span class="line">            <span class="comment">//线程退出</span></span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ThreadPoolInit</span><span class="params">(pThread_pool_t pThreadPool, <span class="keyword">int</span> thread_num)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线程数量</span></span><br><span class="line">    pThreadPool-&gt;thread_num = thread_num;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为线程id申请空间</span></span><br><span class="line">    pThreadPool-&gt;pThread_id = (<span class="keyword">pthread_t</span> *)<span class="built_in">calloc</span>(thread_num, <span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务队列初始化</span></span><br><span class="line">    ret = TaskQueInit(&amp;pThreadPool-&gt;task_que);</span><br><span class="line">    THREAD_ERROR_CHECK(ret, <span class="string">&quot;TaskQueInit&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ThreadPoolCreate</span><span class="params">(pThread_pool_t pThreadPool)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环创建线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pThreadPool-&gt;thread_num; ++i)&#123;</span><br><span class="line">        <span class="comment">//两种方式</span></span><br><span class="line">        <span class="comment">/* ret = pthread_create(pThreadPool-&gt;pThread_id + i, NULL, thread_func, &amp;pThreadPool-&gt;task_que); */</span></span><br><span class="line">        ret = pthread_create(&amp;pThreadPool-&gt;pThread_id[i], <span class="literal">NULL</span>, thread_func, &amp;pThreadPool-&gt;task_que);</span><br><span class="line">        THREAD_ERROR_CHECK(ret, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="taskquec任务队列相关函数"><a class="markdownIt-Anchor" href="#taskquec任务队列相关函数"></a> TaskQue.c：任务队列相关函数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队列初始化函数，初始化任务队列中的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TaskQueInit</span><span class="params">(pTask_que_t pTaskQue)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    pTaskQue-&gt;que_len = <span class="number">0</span>;</span><br><span class="line">    pTaskQue-&gt;pHead = <span class="literal">NULL</span>;</span><br><span class="line">    pTaskQue-&gt;pTail = <span class="literal">NULL</span>;</span><br><span class="line">    ret = pthread_cond_init(&amp;pTaskQue-&gt;que_cond, <span class="literal">NULL</span>);</span><br><span class="line">    THREAD_ERROR_CHECK(ret, <span class="string">&quot;pthread_cond_init&quot;</span>);</span><br><span class="line">    ret = pthread_mutex_init(&amp;pTaskQue-&gt;que_mutex, <span class="literal">NULL</span>);</span><br><span class="line">    THREAD_ERROR_CHECK(ret, <span class="string">&quot;pthread_mutex_init&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队，尾插法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InsertTaskQue</span><span class="params">(pTask_que_t pTaskQue, pTask_node_t pTaskNode)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//任务队列中没有任务节点时，头尾指针指向新加入的任务节点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == pTaskQue-&gt;que_len)&#123;</span><br><span class="line">        pTaskQue-&gt;pHead = pTaskNode;</span><br><span class="line">        pTaskQue-&gt;pTail = pTaskNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有节点，尾插法</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        pTaskQue-&gt;pTail-&gt;pNext = pTaskNode;</span><br><span class="line">        pTaskQue-&gt;pTail = pTaskNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队后队列长度+1</span></span><br><span class="line">    ++pTaskQue-&gt;que_len;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队，头部删除法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTaskNode</span><span class="params">(pTask_que_t pTaskQue, pTask_node_t *pGetTaskNode)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有节点，头部删除法</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> != pTaskQue-&gt;que_len)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//待取出的节点指向头指针</span></span><br><span class="line">        *pGetTaskNode = pTaskQue-&gt;pHead;</span><br><span class="line">        pTaskQue-&gt;pHead = pTaskQue-&gt;pHead-&gt;pNext;</span><br><span class="line">        (*pGetTaskNode)-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//出队后队列长度-1</span></span><br><span class="line">        --pTaskQue-&gt;que_len;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//取完后队列长度为0，把尾指针置空</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == pTaskQue-&gt;que_len)&#123;</span><br><span class="line">            pTaskQue-&gt;pTail = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没节点，返回0</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="tcpinitc-transfilec-epolladdfdc前文进程池中定义过的函数"><a class="markdownIt-Anchor" href="#tcpinitc-transfilec-epolladdfdc前文进程池中定义过的函数"></a> TcpInit.c、TransFile.c、EpollAddFd.c：前文进程池中定义过的函数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TcpInit</span><span class="params">(<span class="keyword">char</span> *ip, <span class="keyword">char</span>*port, <span class="keyword">int</span> *socket_fd)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="comment">/*分别设置协议、IP地址和端口号*/</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line">    addr.sin_port = htons(atoi(port));</span><br><span class="line"></span><br><span class="line">    *socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(*socket_fd, <span class="number">-1</span>, <span class="string">&quot;socket&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置地址可重用</span></span><br><span class="line">    <span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">    ret = setsockopt(*socket_fd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置缓冲区大小</span></span><br><span class="line">    <span class="keyword">int</span> buf = <span class="number">65536</span>;</span><br><span class="line">    ret = setsockopt(*socket_fd, SOL_SOCKET, SO_SNDBUF, &amp;buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绑定ip地址和端口号</span></span><br><span class="line">    ret = bind(*socket_fd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;bind&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听描述符，最大连接数设置为10</span></span><br><span class="line">    ret = listen(*socket_fd, <span class="number">10</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;ret&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigfunc</span><span class="params">(<span class="keyword">int</span> signum)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGPIPE is coming&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TransFile</span><span class="params">(<span class="keyword">int</span> client_fd)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    signal(SIGPIPE, sigfunc);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;1.pdf&quot;</span>, O_RDWR);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;open&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前文件的状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">fileInfo</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;fileInfo, <span class="number">0</span>, <span class="keyword">sizeof</span>(fileInfo));</span><br><span class="line">    ret = fstat(fd, &amp;fileInfo);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;fstat&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建传输数据结构体</span></span><br><span class="line">    <span class="keyword">train_t</span> train;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;train, <span class="number">0</span>, <span class="keyword">sizeof</span>(train));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送文件名</span></span><br><span class="line">    train.data_len = <span class="built_in">strlen</span>(<span class="string">&quot;1.pdf&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(train.data_buf, <span class="string">&quot;1.pdf&quot;</span>);</span><br><span class="line">    ret = send(client_fd, &amp;train, <span class="number">4</span> + train.data_len, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;send&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;train, <span class="number">0</span>, <span class="keyword">sizeof</span>(train));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送文件大小</span></span><br><span class="line">    train.data_len = <span class="keyword">sizeof</span>(fileInfo.st_size);</span><br><span class="line">    <span class="built_in">memcpy</span>(train.data_buf, &amp;fileInfo.st_size, <span class="keyword">sizeof</span>(<span class="keyword">off_t</span>));</span><br><span class="line">    send(client_fd, &amp;train, <span class="number">4</span> + train.data_len, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fileSize = %ld\n&quot;</span>, fileInfo.st_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> send_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    pipe(fds);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(send_size &lt; fileInfo.st_size)&#123;</span><br><span class="line">        ret = splice(fd, <span class="number">0</span>, fds[<span class="number">1</span>], <span class="number">0</span>, <span class="number">64</span>, <span class="number">0</span>);</span><br><span class="line">        ret = splice(fds[<span class="number">0</span>], <span class="number">0</span>, client_fd, <span class="number">0</span>, ret, <span class="number">0</span>);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;splice&quot;</span>);</span><br><span class="line">        send_size += ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fds[<span class="number">0</span>]);</span><br><span class="line">    close(fds[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EpollAddFd</span><span class="params">(<span class="keyword">int</span> epoll_fd, <span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;events, <span class="number">0</span>, <span class="keyword">sizeof</span>(events));</span><br><span class="line"></span><br><span class="line">    events.events = EPOLLIN;</span><br><span class="line">    events.data.fd = fd;</span><br><span class="line"></span><br><span class="line">    ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;events);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="客户端用前文进程池的客户端即可"><a class="markdownIt-Anchor" href="#客户端用前文进程池的客户端即可"></a> 客户端：用前文进程池的客户端即可</h3>
<h1 id="遇到的问题"><a class="markdownIt-Anchor" href="#遇到的问题"></a> 遇到的问题</h1>
<ol>
<li>
<p>free任务节点空间时报错。</p>
<ul>
<li>原因：创建任务节点时，一开始用的是栈空间申请，子线程取节点服务完服务器后无法通过free释放节点空间，会报错。</li>
<li>解决办法：使用堆空间申请任务节点，使用完后能方便的清理空间。</li>
</ul>
</li>
<li>
<p>入队、出队的时候忘记对队列长度进程+1、-1操作，程序报错。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>进程池</title>
    <url>/2021/07/12/%E8%BF%9B%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="进程池"><a class="markdownIt-Anchor" href="#进程池"></a> 进程池</h1>
<ul>
<li>
<p>目的：实现多个客户端同时访问服务器获得服务(本文例子为下载文件)</p>
</li>
<li>
<p>好处：1. 降低资源消耗；2. 提高响应速度；3. 提高进程的可管理性。</p>
</li>
</ul>
<span id="more"></span>
<h2 id="主要工作流程"><a class="markdownIt-Anchor" href="#主要工作流程"></a> 主要工作流程：</h2>
<ul>
<li>父进程：
<ol>
<li>循环创建子进程，记录子进程的相关信息(子进程进程ID，进程的状态，子进程与服务端通信时的文件描述符)。查看是否创建成功：<code>ps -elf | grep [端口号]</code>可以查看子进程是否创建成功。</li>
<li>创建TCP监听套接字，等待客户端的连接请求，查看是否再监听：<code>netstat -nat</code>需要安装。</li>
<li>创建epoll，把需要监听的文件描述符都添加到epoll中，子进程与服务器通信的文件描述符也要加入到epoll当中。</li>
<li>如果客户端请求服务器，使用accept函数接收这次连接请求并返回一个用于与客户端通信的文件描述符，将其发送给子进程(使用sendmsg发送，需要一个msg结构体)，让子进程用该文件描述符与其通信，服务客户端，并将子进程状态设置为忙碌。—&gt;转到子进程。</li>
<li>如果epoll监听到子进程发送的结束信息，主进程将子进程状态设置为不忙碌。</li>
</ol>
</li>
<li>子进程：
<ol>
<li>子进程阻塞，等待父进程发送与客户端相互通信的文件描述符(使用recvmsg函数接收)，用于服务客户端。</li>
<li>服务完客户端之后，关闭与客户端的连接，通知父进程，由父进程将子进程的工作状态设置为不忙碌。</li>
<li>继续等待下一次任务。</li>
</ol>
</li>
</ul>
<h2 id="客户端从服务器下载文件流程"><a class="markdownIt-Anchor" href="#客户端从服务器下载文件流程"></a> 客户端从服务器下载文件流程：</h2>
<ul>
<li>服务器：
<ol>
<li>发送文件名，打开文件。</li>
<li>读取文件，发送文件内容。</li>
</ol>
</li>
<li>客户端：
<ol>
<li>接收文件名，创建同名文件。</li>
<li>接收文件内容，写入同名文件。</li>
</ol>
</li>
<li>文件检测：用md5sum命令对文件计算哈希值，获得相同值说明文件传输成功。</li>
</ul>
<h1 id="服务器设计"><a class="markdownIt-Anchor" href="#服务器设计"></a> 服务器设计</h1>
<h2 id="数据结构设计"><a class="markdownIt-Anchor" href="#数据结构设计"></a> 数据结构设计：</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pipe_fd：与主进程进行通信的文件描述符</span></span><br><span class="line"><span class="comment">busy_status：子进程忙碌状态</span></span><br><span class="line"><span class="comment">pid：子进程的pid</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_BUSY 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_NO_BUSY 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">process_info_s</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> pipe_fd;</span><br><span class="line">    <span class="keyword">int</span> busy_status;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">&#125;<span class="keyword">process_info_t</span>, *pProcess_info_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">data_len：传输数据的长度</span></span><br><span class="line"><span class="comment">data_buf：传输的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data_len;</span><br><span class="line">    <span class="keyword">char</span> data_buf[<span class="number">1000</span>];</span><br><span class="line">&#125;<span class="keyword">train_t</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="程序设计"><a class="markdownIt-Anchor" href="#程序设计"></a> 程序设计：</h2>
<h3 id="mainc主程序"><a class="markdownIt-Anchor" href="#mainc主程序"></a> main.c：主程序</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.循环创建子进程，并记录子进程的相关信息</span></span><br><span class="line">    <span class="keyword">int</span> process_num = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">    pProcess_info_t pInfo = (pProcess_info_t)<span class="built_in">calloc</span>(process_num, <span class="keyword">sizeof</span>(<span class="keyword">process_info_t</span>));</span><br><span class="line">    ret = CreateProcess(pInfo, process_num);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;CreateProcess&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.创建tcp监听套接字，等待客户端连接</span></span><br><span class="line">    <span class="keyword">int</span> socket_fd = <span class="number">0</span>;</span><br><span class="line">    ret = TcpInit(argv[<span class="number">1</span>], argv[<span class="number">2</span>], &amp;socket_fd);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;TcpInit&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.创建epoll</span></span><br><span class="line">    <span class="keyword">int</span> epoll_fd = epoll_create(<span class="number">1</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把所有需要监听的描述符添加到epoll当中</span></span><br><span class="line">    EpollAddFd(epoll_fd, socket_fd);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process_num; ++i)&#123;</span><br><span class="line">        EpollAddFd(epoll_fd, pInfo[i].pipe_fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建epoll_event结构体数组，用于存储</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span>[2];</span></span><br><span class="line">    <span class="built_in">memset</span>(evs, <span class="number">0</span>, <span class="keyword">sizeof</span>(evs));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建new_fd用于接收客户端连接和数据</span></span><br><span class="line">    <span class="keyword">int</span> new_fd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示就绪的文件描述符数量</span></span><br><span class="line">    <span class="keyword">int</span> ready_fd_num = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得活跃的文件描述符数量，-1表示无条件等待</span></span><br><span class="line">        ready_fd_num = epoll_wait(epoll_fd, evs, <span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ready_fd_num; ++i)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//socket_fd就绪，服务器主进程接收连接，得到new_fd寻找空闲子进程</span></span><br><span class="line">            <span class="keyword">if</span>(evs[i].data.fd == socket_fd)&#123;</span><br><span class="line">                <span class="comment">//4.如果客户端连接服务器，使用accept接受这次连接请求，返回一个new_fd，并将new_fd交给空闲子进程</span></span><br><span class="line">                new_fd = accept(socket_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; process_num; ++j)&#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//如果该子进程不繁忙，传递文件描述符给子进程，修改子进程忙碌状态，退出循环</span></span><br><span class="line">                    <span class="keyword">if</span>(PROCESS_NO_BUSY == pInfo[j].busy_status)&#123;</span><br><span class="line">                        SendFd(pInfo[j].pipe_fd, new_fd);</span><br><span class="line">                        pInfo[j].busy_status = PROCESS_BUSY;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;process %d is busy.\n&quot;</span>, pInfo[j].pid);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//传给子进程的new_fd和子进程获取的new_fd指向同一片区域但数值不相同，因此关闭主进程的new_fd不影响子进程对new_fd的读写</span></span><br><span class="line">                close(new_fd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环遍历子进程的pipe_fd看是否有就绪的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; process_num; ++j)&#123;</span><br><span class="line">                <span class="comment">//5.epoll监听到pipe_fd可读，表示子进程工作完成，把子进程工作状态置为空闲</span></span><br><span class="line">                <span class="keyword">if</span>(evs[i].data.fd == pInfo[j].pipe_fd)&#123;</span><br><span class="line">                    <span class="comment">//用于接收子进程完成的信息</span></span><br><span class="line">                    <span class="keyword">char</span> buf[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                    ret = read(pInfo[j].pipe_fd, buf, <span class="number">2</span>);</span><br><span class="line">                    pInfo[j].busy_status = PROCESS_NO_BUSY;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;process %d is not busy.\n&quot;</span>, pInfo[j].pid);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="createprocessc创建子进程"><a class="markdownIt-Anchor" href="#createprocessc创建子进程"></a> CreateProcess.c：创建子进程</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreateProcess</span><span class="params">(pProcess_info_t pInfo,<span class="keyword">int</span> process_num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process_num; ++i)&#123;</span><br><span class="line">        <span class="comment">//创建一对相连的套接口，类似于全双工管道，只能在本机中使用</span></span><br><span class="line">        ret = socketpair(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>, fds);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;socketpair&quot;</span>);</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == pid)&#123;</span><br><span class="line">            close(fds[<span class="number">0</span>]);</span><br><span class="line">            ChildFunc(fds[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fds[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//记录子进程的相关信息</span></span><br><span class="line">        pInfo[i].pid = pid;</span><br><span class="line">        <span class="comment">//!!!!!!!!!!!!!!!!!!给错了pInfo[i].pipe_fd = fds[1];导致epoll_add出错了</span></span><br><span class="line">        pInfo[i].pipe_fd = fds[<span class="number">0</span>];</span><br><span class="line">        pInfo[i].busy_status = PROCESS_NO_BUSY;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="childfuncc子进程函数用于写对客户端的服务"><a class="markdownIt-Anchor" href="#childfuncc子进程函数用于写对客户端的服务"></a> ChildFunc.c：子进程函数，用于写对客户端的服务</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ChildFunc</span><span class="params">(<span class="keyword">int</span> pipe_fd)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用client_fd接收从主进程传来的new_fd</span></span><br><span class="line">    <span class="keyword">int</span> client_fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.调用RecvFd函数用于接收与客户端通信的client_fd</span></span><br><span class="line">        ret = RecvFd(pipe_fd, &amp;client_fd);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;RecvFd&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.传输文件给客户端，不需要报错，报错正常执行，不能因为客户端导致服务器崩溃</span></span><br><span class="line">        TransFile(client_fd);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.通知父进程服务完成</span></span><br><span class="line">        ret = write(pipe_fd, <span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;write&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.关闭client_fd</span></span><br><span class="line">        close(client_fd);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="recvfdc子进程接收主进程发送的与客户端通信的文件描述符"><a class="markdownIt-Anchor" href="#recvfdc子进程接收主进程发送的与客户端通信的文件描述符"></a> RecvFd.c：子进程接收主进程发送的与客户端通信的文件描述符</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RecvFd</span><span class="params">(<span class="keyword">int</span> pipe_fd, <span class="keyword">int</span> *new_fd)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建sendmsg可用的数据结构体msg，并初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建msg中的iovec结构体iov，并初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;iov, <span class="number">0</span>, <span class="keyword">sizeof</span>(iov));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//iovec必须要赋值，iov.iov_base存储的是一个地址</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    iov.iov_base = buf;</span><br><span class="line">    iov.iov_len = <span class="built_in">strlen</span>(buf);</span><br><span class="line"></span><br><span class="line">    msg.msg_iov = &amp;iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//因为cmsg中有个柔性数组，所以只能申请堆空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cmsg</span> =</span> (struct cmsghdr*)<span class="built_in">calloc</span>(<span class="number">1</span>, len);</span><br><span class="line">    cmsg-&gt;cmsg_len = len;</span><br><span class="line">    cmsg-&gt;cmsg_level = SOL_SOCKET;</span><br><span class="line">    cmsg-&gt;cmsg_type = SCM_RIGHTS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//msg的附属数据结构体指向cmsg</span></span><br><span class="line">    msg.msg_control = cmsg;</span><br><span class="line">    msg.msg_controllen = len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用pipe_fd向子进程接收msg</span></span><br><span class="line">    <span class="comment">//用ssize_t recvmsg(int sockfd, const struct msghdr *msg, int flags)可以发送文件描述符</span></span><br><span class="line">    recvmsg(pipe_fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//柔性数组的数据用CMSG_DATA()接收，要进行类型转换</span></span><br><span class="line">    *new_fd = *(<span class="keyword">int</span>*)CMSG_DATA(cmsg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="sendfdc主进程发送与客户端通信的文件描述符给子进程"><a class="markdownIt-Anchor" href="#sendfdc主进程发送与客户端通信的文件描述符给子进程"></a> SendFd.c：主进程发送与客户端通信的文件描述符给子进程</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SendFd</span><span class="params">(<span class="keyword">int</span> pipe_fd, <span class="keyword">int</span> new_fd)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建sendmsg可用的数据结构体msg，并初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建msg中的iovec结构体iov，并初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;iov, <span class="number">0</span>, <span class="keyword">sizeof</span>(iov));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//iovec必须要赋值，iov.iov_base存储的是一个地址</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    iov.iov_base = buf;</span><br><span class="line">    iov.iov_len = <span class="built_in">strlen</span>(buf);</span><br><span class="line"></span><br><span class="line">    msg.msg_iov = &amp;iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//因为cmsg中有个柔性数组，所以只能申请堆空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cmsg</span> =</span> (struct cmsghdr*)<span class="built_in">calloc</span>(<span class="number">1</span>, len);</span><br><span class="line">    cmsg-&gt;cmsg_len = len;</span><br><span class="line">    cmsg-&gt;cmsg_level = SOL_SOCKET;</span><br><span class="line">    cmsg-&gt;cmsg_type = SCM_RIGHTS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//柔性数组的数据用CMSG_DATA()接收，要进行类型转换</span></span><br><span class="line">    *(<span class="keyword">int</span>*)CMSG_DATA(cmsg) = new_fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//msg的附属数据结构体指向cmsg</span></span><br><span class="line">    msg.msg_control = cmsg;</span><br><span class="line">    msg.msg_controllen = len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用pipe_fd向子进程发送msg</span></span><br><span class="line">    <span class="comment">//用ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags)可以发送文件描述符</span></span><br><span class="line">    sendmsg(pipe_fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="transfilec文件传输函数"><a class="markdownIt-Anchor" href="#transfilec文件传输函数"></a> TransFile.c：文件传输函数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接收一次SIGPIPE信号，防止信号中断程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigfunc</span><span class="params">(<span class="keyword">int</span> signum)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGPIPE is coimg&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TransFile</span><span class="params">(<span class="keyword">int</span> client_fd)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    signal(SIGPIPE, sigfunc);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;1.pdf&quot;</span>, O_RDONLY);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;open&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前文件的状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">fileInfo</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;fileInfo, <span class="number">0</span>, <span class="keyword">sizeof</span>(fileInfo));</span><br><span class="line">    ret = fstat(fd, &amp;fileInfo);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;fstat&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建传输数据结构体</span></span><br><span class="line">    <span class="keyword">train_t</span> train;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;train, <span class="number">0</span>, <span class="keyword">sizeof</span>(train));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送文件名</span></span><br><span class="line">    train.data_len = <span class="built_in">strlen</span>(<span class="string">&quot;1.pdf&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(train.data_buf, <span class="string">&quot;1.pdf&quot;</span>);</span><br><span class="line">    ret = send(client_fd, &amp;train, <span class="number">4</span> + train.data_len, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;send&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;train, <span class="number">0</span>, <span class="keyword">sizeof</span>(train));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送文件大小</span></span><br><span class="line">    train.data_len = <span class="keyword">sizeof</span>(fileInfo.st_size);</span><br><span class="line">    <span class="built_in">memcpy</span>(train.data_buf, &amp;fileInfo.st_size, <span class="keyword">sizeof</span>(<span class="keyword">off_t</span>));</span><br><span class="line">    send(client_fd, &amp;train, <span class="number">4</span> + train.data_len, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fileSize = %ld\n&quot;</span>, fileInfo.st_size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//----------------------------------零拷贝修改区----------------------------------//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;train, <span class="number">0</span>, <span class="keyword">sizeof</span>(train));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环文件发送数据</span></span><br><span class="line">        train.data_len = read(fd, train.data_buf, <span class="keyword">sizeof</span>(train.data_buf));</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == train.data_len)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送错误则退出发送</span></span><br><span class="line">        ret = send(client_fd, &amp;train, train.data_len + <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;TransFile_send&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//发送数据为0时退出循环</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == train.data_len)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//----------------------------------零拷贝修改区----------------------------------//</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="tcpinitc创建主进程的tcp监听套接字"><a class="markdownIt-Anchor" href="#tcpinitc创建主进程的tcp监听套接字"></a> TcpInit.c：创建主进程的TCP监听套接字</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TcpInit</span><span class="params">(<span class="keyword">char</span> *ip, <span class="keyword">char</span>*port, <span class="keyword">int</span> *socket_fd)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="comment">/*分别设置协议、IP地址和端口号*/</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line">    addr.sin_port = htons(atoi(port));</span><br><span class="line"></span><br><span class="line">    *socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(*socket_fd, <span class="number">-1</span>, <span class="string">&quot;socket&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置地址可重用</span></span><br><span class="line">    <span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">    ret = setsockopt(*socket_fd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置缓冲区大小</span></span><br><span class="line">    <span class="keyword">int</span> buf = <span class="number">65536</span>;</span><br><span class="line">    ret = setsockopt(*socket_fd, SOL_SOCKET, SO_SNDBUF, &amp;buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绑定ip地址和端口号</span></span><br><span class="line">    ret = bind(*socket_fd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;bind&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听描述符，最大连接数设置为10</span></span><br><span class="line">    ret = listen(*socket_fd, <span class="number">10</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;ret&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="epolladdfdc将文件描述符添加进epoll"><a class="markdownIt-Anchor" href="#epolladdfdc将文件描述符添加进epoll"></a> EpollAddFd.c：将文件描述符添加进epoll</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EpollAddFd</span><span class="params">(<span class="keyword">int</span> epoll_fd, <span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;events, <span class="number">0</span>, <span class="keyword">sizeof</span>(events));</span><br><span class="line">    events.events = EPOLLIN;</span><br><span class="line">    events.data.fd = fd;</span><br><span class="line">    <span class="comment">//将fd添加进epoll</span></span><br><span class="line">    <span class="keyword">int</span> ret = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;events);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="客户端设计"><a class="markdownIt-Anchor" href="#客户端设计"></a> 客户端设计</h1>
<h2 id="程序设计-2"><a class="markdownIt-Anchor" href="#程序设计-2"></a> 程序设计</h2>
<h3 id="clientc客户端主程序"><a class="markdownIt-Anchor" href="#clientc客户端主程序"></a> client.c：客户端主程序</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存服务器端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套接字文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(socket_fd, <span class="number">-1</span>, <span class="string">&quot;socket&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置接收缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> recv_buf = <span class="number">65536</span>;</span><br><span class="line">    ret = setsockopt(socket_fd, SOL_SOCKET, SO_RCVBUF, &amp;recv_buf, <span class="keyword">sizeof</span>(recv_buf));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    ret = connect(socket_fd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;connect&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> data_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">off_t</span> file_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.先接收文件名长度</span></span><br><span class="line">    ret = recv(socket_fd, &amp;data_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;recv_name_len&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.根据文件名长度接收文件名</span></span><br><span class="line">    ret = recv(socket_fd, buf, data_len, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;recv_name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.接收文件大小</span></span><br><span class="line">    ret = recv(socket_fd, &amp;data_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">    ret = recv(socket_fd, &amp;file_len, data_len, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.根据文件名打开文件</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(buf, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    ERROR_CHECK(fd, <span class="number">-1</span>, <span class="string">&quot;open&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------------------------零拷贝修改区----------------------------------//</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置接收文件的大小</span></span><br><span class="line">    <span class="keyword">off_t</span> file_len_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计次数打印进度条</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//!!!!!!!!!!!!!!!!!!!!!!!!清空缓冲区!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.接收文件长度</span></span><br><span class="line">        recv(socket_fd, &amp;data_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == data_len)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.接收文件数据</span></span><br><span class="line">        ret = RecvFile(socket_fd, buf, data_len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.统计现有文件大小，打印进度条</span></span><br><span class="line">        file_len_num += ret;</span><br><span class="line">        cnt = PrintProgressRate(file_len, file_len_num, cnt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.写入文件</span></span><br><span class="line">        write(fd, buf, data_len);</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------------------------零拷贝修改区----------------------------------//</span></span><br><span class="line"></span><br><span class="line">    close(socket_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="recvfilec封装一个接收指定大小数据的函数"><a class="markdownIt-Anchor" href="#recvfilec封装一个接收指定大小数据的函数"></a> RecvFile.c：封装一个接收指定大小数据的函数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RecvFile</span><span class="params">(<span class="keyword">int</span> socket_fd, <span class="keyword">void</span> *buf, <span class="keyword">int</span> data_len)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> get_file_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(get_file_len &lt; data_len)&#123;</span><br><span class="line">        <span class="comment">//动态接收数据，等到接收数据达到想要接受的长度时退出</span></span><br><span class="line">        ret = recv(socket_fd, (<span class="keyword">char</span> *)buf + get_file_len, data_len - get_file_len, <span class="number">0</span>);</span><br><span class="line">        get_file_len += ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> get_file_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="printprogressratec打印进度条程序"><a class="markdownIt-Anchor" href="#printprogressratec打印进度条程序"></a> PrintProgressRate.c：打印进度条程序</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PrintProgressRate</span><span class="params">(<span class="keyword">off_t</span> final_num, <span class="keyword">off_t</span> now_num, <span class="keyword">int</span> cnt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> all = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">2</span>] = <span class="string">&quot;%&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(final_num == now_num)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; all; ++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;█&quot;</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;100.00%s\n&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">100</span> == ++cnt)&#123;</span><br><span class="line">        <span class="keyword">double</span> bar = (<span class="keyword">double</span>)now_num / final_num * <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> space_num = all - (<span class="keyword">int</span>)bar / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; all - space_num; ++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;█&quot;</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; space_num - <span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5.2lf%s\r&quot;</span>, bar, str);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="遇到的问题"><a class="markdownIt-Anchor" href="#遇到的问题"></a> 遇到的问题</h1>
<ol>
<li>发送文件名和文件数据粘在一块。
<ul>
<li>原因：TCP粘包问题，多次发送的数据被一次接收，数据之间没有分界线，所有数据都粘在一起。</li>
<li>解决方法：人为去设计一个结构体，规定数据与数据之间的分界线(私有协议)。</li>
</ul>
</li>
<li>客户端接收文件时，接收到的文件和服务器上的文件大小内容不一样，但是传输过程没有问题。
<ul>
<li>原因：循环接收时没有清空接收缓冲区，导致错误接收。</li>
<li>解决办法：清空接收缓冲区。</li>
</ul>
</li>
<li>客户端报栈损坏、段错误。
<ul>
<li>原因：由于发送速度不匹配，造成客户端接收数据时读取数据时不一定时正确的顺序。读取认为规定的结构体时发生错误的读取，读取到错误的数据长度，导致客户端访问到了不能访问的内存空间因此程序崩溃。</li>
<li>解决方案：①设置recv的标志位为MSG_WAITALL；②封装自己的recv函数规定接收数据大小；③写一个ERROR_CHECK()宏检测，检测到错误即使返回。</li>
</ul>
</li>
<li>客户端主动退出，服务器崩溃。
<ul>
<li>原因：服务器子程序发送失败时，用了一个ERROR_CHECK()宏检测，导致子进程异常退出，父进程与子进程间通信的文件描述符成为一个无效的文件描述符，子进程会循环发送SIGPIPE信号。</li>
<li>解决办法：传输文件处写一个signal函数捕捉SIGPIPE信号。子进程传输失败时不予理会，当作服务完成，正常向后执行（<strong>不能因为客户端的问题引起服务器崩溃</strong>）。</li>
</ul>
</li>
<li>小错误：<strong>创建并存储子进程信息时(CreateProcess.c)，发生关闭该管道又存储该管道，epoll_add的时候出现报错。</strong></li>
</ol>
<h1 id="后续可以做的改进"><a class="markdownIt-Anchor" href="#后续可以做的改进"></a> 后续可以做的改进</h1>
<ol>
<li>
<p>零拷贝传输：先前传输文件时循环调用send系统调用，发生用户态到内核态再由内核态到用户态的拷贝，使用零拷贝技术，减少内核态和用户台之间的拷贝次数，从而加快服务器传输速率。</p>
<p>客户端使用零拷贝技术接收（修改client.c的修改区使用mmap）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">beg</span>, <span class="title">end</span>;</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp;beg, <span class="number">0</span>, <span class="keyword">sizeof</span>(beg));</span><br><span class="line">   <span class="built_in">memset</span>(&amp;end, <span class="number">0</span>, <span class="keyword">sizeof</span>(end));</span><br><span class="line">   </span><br><span class="line">   gettimeofday(&amp;beg, <span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line">   ftruncate(fd, file_len);</span><br><span class="line">   <span class="comment">//用mmap进行地址映射</span></span><br><span class="line">   <span class="keyword">char</span> *<span class="built_in">map</span> = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, file_len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">   ERROR_CHECK(<span class="built_in">map</span>, (<span class="keyword">char</span> *)<span class="number">-1</span>, <span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   recv(socket_fd, <span class="built_in">map</span>, file_len, MSG_WAITALL);</span><br><span class="line">   </span><br><span class="line">   munmap(<span class="built_in">map</span>, file_len);</span><br><span class="line">   </span><br><span class="line">   gettimeofday(&amp;end, <span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line"><span class="comment">//可以统计传输效率</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;total time = %lf\n&quot;</span>, (end.tv_sec - beg.tv_sec) + ((end.tv_usec - beg.tv_usec) / <span class="number">1000.0</span>) / <span class="number">1000.0</span>);</span><br></pre></td></tr></table></figure>
<p>服务器的三种零拷贝技术（修该TransFile.c的修改区）：</p>
<ul>
<li>
<p>mmap文件映射：传输240M文件0.9s左右</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.用mmap进行地址映射</span></span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">map</span> = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, fileInfo.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>); </span><br><span class="line">ERROR_CHECK(<span class="built_in">map</span>, (<span class="keyword">void</span> *)<span class="number">-1</span>, <span class="string">&quot;mmap&quot;</span>); </span><br><span class="line"><span class="comment">//发送整个map </span></span><br><span class="line">send(client_fd, <span class="built_in">map</span>, fileInfo.st_size, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//解映射</span></span><br><span class="line">munmap(<span class="built_in">map</span>, fileInfo.st_size);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>sendfile函数：传输240M文件0.7s左右</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ssize_t sendfile(int out_fd, int fd, off_t *offset, size_t count)</span></span><br><span class="line"><span class="comment">成功返回发送的字节数，失败返回-1</span></span><br><span class="line"><span class="comment">参数1：往哪写入数据</span></span><br><span class="line"><span class="comment">参数2：从哪读取数据</span></span><br><span class="line"><span class="comment">参数3：文件偏移量</span></span><br><span class="line"><span class="comment">参数4：传输数据的长度</span></span><br><span class="line"><span class="comment">sendfile只能用于发送端发送数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//2.用sendfile发送文件</span></span><br><span class="line">ret = sendfile(client_fd, fd, <span class="number">0</span>, fileInfo.st_size);</span><br><span class="line">ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;sendfile&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>splice函数：传输240M文件，发送大小设置128时需要2.2s左右，发送大小设置为65536时需要0.7s左右</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需要打开一个宏开关：#define _GNU_SOURCE</span></span><br><span class="line"><span class="comment">需要一根管道，用于发送和接收数据</span></span><br><span class="line"><span class="comment">ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags)</span></span><br><span class="line"><span class="comment">成功返回发送的字节数，失败返回-1</span></span><br><span class="line"><span class="comment">参数1：从哪取数据</span></span><br><span class="line"><span class="comment">参数2：偏移量</span></span><br><span class="line"><span class="comment">参数3：往哪写数据</span></span><br><span class="line"><span class="comment">参数4：偏移量</span></span><br><span class="line"><span class="comment">参数5：单次写入数据长度（最多65536）---&gt;可以通过这个的大小控制传输速度</span></span><br><span class="line"><span class="comment">参数6：标识位，一般填0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//3.用户splice传输文件，要利用一根管道，用文件描述符往里写，客户端通信文件描述符从里面取</span></span><br><span class="line"><span class="keyword">long</span> send_size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fds[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">pipe(fds);</span><br><span class="line"><span class="keyword">while</span>(send_size &lt; fileInfo.st_size)&#123;</span><br><span class="line">    ret = splice(fd, <span class="number">0</span>, fds[<span class="number">1</span>], <span class="number">0</span>, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">    ret = splice(fds[<span class="number">0</span>], <span class="number">0</span>, client_fd, <span class="number">0</span>, ret, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;splice&quot;</span>);</span><br><span class="line">    send_size += ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>四种发送文件对比：</p>
<ul>
<li>文件速度：sendfile &gt; mmap &gt; send，splice可以自行控制速度。</li>
<li>限制：
<ol>
<li>sendfile和mmap有文件大小限制，最大可以传输2G的大文件。</li>
<li>零拷贝接口的可移植性不是很好。</li>
<li>数据传输的瓶颈始终在于<strong>网络状态</strong>。</li>
</ol>
</li>
</ul>
</li>
<li>
<p>进程池的退出。</p>
<ul>
<li>
<p>暴力退出：父进程收到退出信号后，依次杀死子进程。</p>
<p>服务器main.c添加一个全局变量out标识符，一个信号捕捉函数和一个信号处理函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局out标识位</span></span><br><span class="line"><span class="keyword">short</span> out = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main_sigfunc</span><span class="params">(<span class="keyword">int</span> signum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">10</span> == signum)&#123;</span><br><span class="line">        out = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号捕捉函数添加在创建子进程后面，以防子进程继承主函数的信号捕捉函数</span></span><br><span class="line">signal(<span class="number">10</span>, main_sigfunc);</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴力退出子进程，加在主函数while(1)中</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> == out)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process_num; ++i)&#123;</span><br><span class="line">        kill(pInfo[i].pid, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main out\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器ChildFunc.c添加一个信号捕捉函数和处理函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">child_sigfunc</span><span class="params">(<span class="keyword">int</span> signum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">10</span> == signum)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child out\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号捕捉函数</span></span><br><span class="line">signal(<span class="number">10</span>, child_sigfunc);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>温柔退出：父进程收到退出信号后，给子进程发送退出标记，如果子进程正在忙碌，忙完后自行退出。</p>
<p>main.c修改：添加一个全局管道，用于在程序捕捉到10号信号时，通过异步拉起同步的方式，通过管道发送退出信息给自己，再由自己通知子程序退出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> out_pipe[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main_sigfunc</span><span class="params">(<span class="keyword">int</span> signum)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main get signum = %d\n&quot;</span>, signum);</span><br><span class="line">    <span class="comment">//异步拉起同步的方式</span></span><br><span class="line">    write(out_pipe[<span class="number">1</span>], &amp;signum, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//......此处省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建用于管道</span></span><br><span class="line">    pipe(out_pipe);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加管道读端进epoll</span></span><br><span class="line">    EpollAddFd(epoll_fd, out_pipe[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//......此处省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//获得活跃的文件描述符数量，-1表示无条件等待</span></span><br><span class="line">        ready_fd_num = epoll_wait(epoll_fd, evs, <span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ready_fd_num; ++i)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//服务器收到信号处理函数发给自己的退出信息，给每个子进程发送退出信息</span></span><br><span class="line">            <span class="keyword">if</span>(evs[i].data.fd == out_pipe[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; process_num; ++j)&#123;</span><br><span class="line">                    SendFd(pInfo[j].pipe_fd, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; process_num; ++j)&#123;</span><br><span class="line">                    wait(<span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;main out\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//socket_fd就绪，服务器主进程接收连接，得到new_fd寻找空闲子进程</span></span><br><span class="line">            <span class="keyword">if</span>(evs[i].data.fd == socket_fd)&#123;</span><br><span class="line">                <span class="comment">//4.如果客户端连接服务器，使用accept接受这次连接请求，返回一个new_fd，并将new_fd交给空闲子进程</span></span><br><span class="line">                new_fd = accept(socket_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; process_num; ++j)&#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//如果该子进程不繁忙，传递文件描述符给子进程，修改子进程忙碌状态，退出循环</span></span><br><span class="line">                    <span class="keyword">if</span>(PROCESS_NO_BUSY == pInfo[j].busy_status)&#123;</span><br><span class="line">                        SendFd(pInfo[j].pipe_fd, new_fd, <span class="number">0</span>);</span><br><span class="line">                        pInfo[j].busy_status = PROCESS_BUSY;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;process %d is busy.\n&quot;</span>, pInfo[j].pid);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//传给子进程的new_fd和子进程获取的new_fd指向同一片区域但数值不相同，因此关闭主进程的new_fd不影响子进程对new_fd的读写</span></span><br><span class="line">                close(new_fd);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//......此处省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SendFd.c修改：添加一个out_flag标识位，用于向子进程发送退出消息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SendFd</span><span class="params">(<span class="keyword">int</span> pipe_fd, <span class="keyword">int</span> new_fd, <span class="keyword">int</span> out_flag)</span></span>&#123;</span><br><span class="line">    <span class="comment">//......此处省略</span></span><br><span class="line">    iov.iov_base = &amp;out_flag;</span><br><span class="line">    iov.iov_len = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//......此处省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RecvFd.c修改：添加一个out_flag标识位，用于接收子进程退出消息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RecvFd</span><span class="params">(<span class="keyword">int</span> pipe_fd, <span class="keyword">int</span> *new_fd, <span class="keyword">int</span> *out_flag)</span></span>&#123;</span><br><span class="line">    <span class="comment">//......此处省略</span></span><br><span class="line">    iov.iov_base = out_flag;</span><br><span class="line">    iov.iov_len = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//......此处省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ChildFunc.c修改：添加一个out_flag标识位，用于存储RecvFd函数收到的out_flag标识位，判断是否要退出进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ChildFunc</span><span class="params">(<span class="keyword">int</span> pipe_fd)</span></span>&#123;</span><br><span class="line">    <span class="comment">//......此处省略</span></span><br><span class="line">    <span class="keyword">int</span> out_flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//......此处省略</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.调用RecvFd函数用于接收与客户端通信的client_fd，阻塞性函數</span></span><br><span class="line">        ret = RecvFd(pipe_fd, &amp;client_fd, &amp;out_flag);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;RecvFd&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == out_flag)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child out\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//......此处省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
</search>
