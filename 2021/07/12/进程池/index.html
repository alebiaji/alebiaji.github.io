<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"alebiaji.top","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="进程池流程  目的：实现多个客户端同时访问服务器获得服务(本文例子为下载文件)">
<meta property="og:type" content="article">
<meta property="og:title" content="进程池">
<meta property="og:url" content="http://alebiaji.top/2021/07/12/%E8%BF%9B%E7%A8%8B%E6%B1%A0/index.html">
<meta property="og:site_name" content="Ale&#39;s Blog">
<meta property="og:description" content="进程池流程  目的：实现多个客户端同时访问服务器获得服务(本文例子为下载文件)">
<meta property="og:locale">
<meta property="article:published_time" content="2021-07-12T12:10:20.000Z">
<meta property="article:modified_time" content="2021-07-13T05:14:50.000Z">
<meta property="article:author" content="Alebiaji">
<meta property="article:tag" content="C">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://alebiaji.top/2021/07/12/%E8%BF%9B%E7%A8%8B%E6%B1%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>进程池 | Ale's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ale's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://alebiaji.top/2021/07/12/%E8%BF%9B%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Alebiaji">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ale's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          进程池
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-12 20:10:20" itemprop="dateCreated datePublished" datetime="2021-07-12T20:10:20+08:00">2021-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-13 13:14:50" itemprop="dateModified" datetime="2021-07-13T13:14:50+08:00">2021-07-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="进程池流程"><a class="markdownIt-Anchor" href="#进程池流程"></a> 进程池流程</h1>
<h2 id="目的实现多个客户端同时访问服务器获得服务本文例子为下载文件"><a class="markdownIt-Anchor" href="#目的实现多个客户端同时访问服务器获得服务本文例子为下载文件"></a> 目的：实现多个客户端同时访问服务器获得服务(本文例子为下载文件)</h2>
<span id="more"></span>
<h2 id="好处1-降低资源消耗2-提高响应速度3-提高进程的可管理性"><a class="markdownIt-Anchor" href="#好处1-降低资源消耗2-提高响应速度3-提高进程的可管理性"></a> 好处：1. 降低资源消耗；2. 提高响应速度；3. 提高进程的可管理性。</h2>
<h2 id="主要工作流程"><a class="markdownIt-Anchor" href="#主要工作流程"></a> 主要工作流程：</h2>
<ul>
<li>父进程：
<ol>
<li>循环创建子进程，记录子进程的相关信息(子进程进程ID，进程的状态，子进程与服务端通信时的文件描述符)。查看是否创建成功：<code>ps -elf | grep [端口号]</code>可以查看子进程是否创建成功。</li>
<li>创建TCP监听套接字，等待客户端的连接请求，查看是否再监听：<code>netstat -nat</code>需要安装。</li>
<li>创建epoll，把需要监听的文件描述符都添加到epoll中，子进程与服务器通信的文件描述符也要加入到epoll当中。</li>
<li>如果客户端请求服务器，使用accept函数接收这次连接请求并返回一个用于与客户端通信的文件描述符，将其发送给子进程(使用sendmsg发送，需要一个msg结构体)，让子进程用该文件描述符与其通信，服务客户端，并将子进程状态设置为忙碌。—&gt;转到子进程。</li>
<li>如果epoll监听到子进程发送的结束信息，主进程将子进程状态设置为不忙碌。</li>
</ol>
</li>
<li>子进程：
<ol>
<li>子进程阻塞，等待父进程发送与客户端相互通信的文件描述符(使用recvmsg函数接收)，用于服务客户端。</li>
<li>服务完客户端之后，关闭与客户端的连接，通知父进程，由父进程将子进程的工作状态设置为不忙碌。</li>
<li>继续等待下一次任务。</li>
</ol>
</li>
</ul>
<h2 id="客户端从服务器下载文件流程"><a class="markdownIt-Anchor" href="#客户端从服务器下载文件流程"></a> 客户端从服务器下载文件流程：</h2>
<ul>
<li>服务器：
<ol>
<li>发送文件名，打开文件。</li>
<li>读取文件，发送文件内容。</li>
</ol>
</li>
<li>客户端：
<ol>
<li>接收文件名，创建同名文件。</li>
<li>接收文件内容，写入同名文件。</li>
</ol>
</li>
<li>文件检测：用md5sum命令对文件计算哈希值，获得相同值说明文件传输成功。</li>
</ul>
<h1 id="服务器设计"><a class="markdownIt-Anchor" href="#服务器设计"></a> 服务器设计</h1>
<h2 id="数据结构设计"><a class="markdownIt-Anchor" href="#数据结构设计"></a> 数据结构设计：</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pipe_fd：与主进程进行通信的文件描述符</span></span><br><span class="line"><span class="comment">busy_status：子进程忙碌状态</span></span><br><span class="line"><span class="comment">pid：子进程的pid</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_BUSY 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_NO_BUSY 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">process_info_s</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> pipe_fd;</span><br><span class="line">    <span class="keyword">int</span> busy_status;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">&#125;<span class="keyword">process_info_t</span>, *pProcess_info_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">data_len：传输数据的长度</span></span><br><span class="line"><span class="comment">data_buf：传输的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data_len;</span><br><span class="line">    <span class="keyword">char</span> data_buf[<span class="number">1000</span>];</span><br><span class="line">&#125;<span class="keyword">train_t</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="程序设计"><a class="markdownIt-Anchor" href="#程序设计"></a> 程序设计：</h2>
<h3 id="mainc主程序"><a class="markdownIt-Anchor" href="#mainc主程序"></a> main.c：主程序</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.循环创建子进程，并记录子进程的相关信息</span></span><br><span class="line">    <span class="keyword">int</span> process_num = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">    pProcess_info_t pInfo = (pProcess_info_t)<span class="built_in">calloc</span>(process_num, <span class="keyword">sizeof</span>(<span class="keyword">process_info_t</span>));</span><br><span class="line">    ret = CreateProcess(pInfo, process_num);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;CreateProcess&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.创建tcp监听套接字，等待客户端连接</span></span><br><span class="line">    <span class="keyword">int</span> socket_fd = <span class="number">0</span>;</span><br><span class="line">    ret = TcpInit(argv[<span class="number">1</span>], argv[<span class="number">2</span>], &amp;socket_fd);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;TcpInit&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.创建epoll</span></span><br><span class="line">    <span class="keyword">int</span> epoll_fd = epoll_create(<span class="number">1</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把所有需要监听的描述符添加到epoll当中</span></span><br><span class="line">    EpollAddFd(epoll_fd, socket_fd);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process_num; ++i)&#123;</span><br><span class="line">        EpollAddFd(epoll_fd, pInfo[i].pipe_fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建epoll_event结构体数组，用于存储</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span>[2];</span></span><br><span class="line">    <span class="built_in">memset</span>(evs, <span class="number">0</span>, <span class="keyword">sizeof</span>(evs));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建new_fd用于接收客户端连接和数据</span></span><br><span class="line">    <span class="keyword">int</span> new_fd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示就绪的文件描述符数量</span></span><br><span class="line">    <span class="keyword">int</span> ready_fd_num = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得活跃的文件描述符数量，-1表示无条件等待</span></span><br><span class="line">        ready_fd_num = epoll_wait(epoll_fd, evs, <span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ready_fd_num; ++i)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//socket_fd就绪，服务器主进程接收连接，得到new_fd寻找空闲子进程</span></span><br><span class="line">            <span class="keyword">if</span>(evs[i].data.fd == socket_fd)&#123;</span><br><span class="line">                <span class="comment">//4.如果客户端连接服务器，使用accept接受这次连接请求，返回一个new_fd，并将new_fd交给空闲子进程</span></span><br><span class="line">                new_fd = accept(socket_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; process_num; ++j)&#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//如果该子进程不繁忙，传递文件描述符给子进程，修改子进程忙碌状态，退出循环</span></span><br><span class="line">                    <span class="keyword">if</span>(PROCESS_NO_BUSY == pInfo[j].busy_status)&#123;</span><br><span class="line">                        SendFd(pInfo[j].pipe_fd, new_fd);</span><br><span class="line">                        pInfo[j].busy_status = PROCESS_BUSY;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;process %d is busy.\n&quot;</span>, pInfo[j].pid);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//传给子进程的new_fd和子进程获取的new_fd指向同一片区域但数值不相同，因此关闭主进程的new_fd不影响子进程对new_fd的读写</span></span><br><span class="line">                close(new_fd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环遍历子进程的pipe_fd看是否有就绪的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; process_num; ++j)&#123;</span><br><span class="line">                <span class="comment">//5.epoll监听到pipe_fd可读，表示子进程工作完成，把子进程工作状态置为空闲</span></span><br><span class="line">                <span class="keyword">if</span>(evs[i].data.fd == pInfo[j].pipe_fd)&#123;</span><br><span class="line">                    <span class="comment">//用于接收子进程完成的信息</span></span><br><span class="line">                    <span class="keyword">char</span> buf[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                    ret = read(pInfo[j].pipe_fd, buf, <span class="number">2</span>);</span><br><span class="line">                    pInfo[j].busy_status = PROCESS_NO_BUSY;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;process %d is not busy.\n&quot;</span>, pInfo[j].pid);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="createprocessc创建子进程"><a class="markdownIt-Anchor" href="#createprocessc创建子进程"></a> CreateProcess.c：创建子进程</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreateProcess</span><span class="params">(pProcess_info_t pInfo,<span class="keyword">int</span> process_num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process_num; ++i)&#123;</span><br><span class="line">        <span class="comment">//创建一对相连的套接口，类似于全双工管道，只能在本机中使用</span></span><br><span class="line">        ret = socketpair(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>, fds);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;socketpair&quot;</span>);</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == pid)&#123;</span><br><span class="line">            close(fds[<span class="number">0</span>]);</span><br><span class="line">            ChildFunc(fds[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fds[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//记录子进程的相关信息</span></span><br><span class="line">        pInfo[i].pid = pid;</span><br><span class="line">        pInfo[i].pipe_fd = fds[<span class="number">1</span>];</span><br><span class="line">        pInfo[i].busy_status = PROCESS_NO_BUSY;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="childfuncc子进程函数用于写对客户端的服务"><a class="markdownIt-Anchor" href="#childfuncc子进程函数用于写对客户端的服务"></a> ChildFunc.c：子进程函数，用于写对客户端的服务</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ChildFunc</span><span class="params">(<span class="keyword">int</span> pipe_fd)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用client_fd接收从主进程传来的new_fd</span></span><br><span class="line">    <span class="keyword">int</span> client_fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.调用RecvFd函数用于接收与客户端通信的client_fd</span></span><br><span class="line">        ret = RecvFd(pipe_fd, &amp;client_fd);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;RecvFd&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.传输文件给客户端，不需要报错，报错正常执行，不能因为客户端导致服务器崩溃</span></span><br><span class="line">        TransFile(client_fd);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.通知父进程服务完成</span></span><br><span class="line">        ret = write(pipe_fd, <span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;write&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.关闭client_fd</span></span><br><span class="line">        close(client_fd);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="recvfdc子进程接收主进程发送的与客户端通信的文件描述符"><a class="markdownIt-Anchor" href="#recvfdc子进程接收主进程发送的与客户端通信的文件描述符"></a> RecvFd.c：子进程接收主进程发送的与客户端通信的文件描述符</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RecvFd</span><span class="params">(<span class="keyword">int</span> pipe_fd, <span class="keyword">int</span> *new_fd)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建sendmsg可用的数据结构体msg，并初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建msg中的iovec结构体iov，并初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;iov, <span class="number">0</span>, <span class="keyword">sizeof</span>(iov));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//iovec必须要赋值</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    iov.iov_base = buf;</span><br><span class="line">    iov.iov_len = <span class="built_in">strlen</span>(buf);</span><br><span class="line"></span><br><span class="line">    msg.msg_iov = &amp;iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//因为cmsg中有个柔性数组，所以只能申请堆空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cmsg</span> =</span> (struct cmsghdr*)<span class="built_in">calloc</span>(<span class="number">1</span>, len);</span><br><span class="line">    cmsg-&gt;cmsg_len = len;</span><br><span class="line">    cmsg-&gt;cmsg_level = SOL_SOCKET;</span><br><span class="line">    cmsg-&gt;cmsg_type = SCM_RIGHTS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//msg的附属数据结构体指向cmsg</span></span><br><span class="line">    msg.msg_control = cmsg;</span><br><span class="line">    msg.msg_controllen = len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用pipe_fd向子进程接收msg</span></span><br><span class="line">    <span class="comment">//用ssize_t recvmsg(int sockfd, const struct msghdr *msg, int flags)可以发送文件描述符</span></span><br><span class="line">    recvmsg(pipe_fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//柔性数组的数据用CMSG_DATA()接收，要进行类型转换</span></span><br><span class="line">    *new_fd = *(<span class="keyword">int</span>*)CMSG_DATA(cmsg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="sendfdc主进程发送与客户端通信的文件描述符给子进程"><a class="markdownIt-Anchor" href="#sendfdc主进程发送与客户端通信的文件描述符给子进程"></a> SendFd.c：主进程发送与客户端通信的文件描述符给子进程</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SendFd</span><span class="params">(<span class="keyword">int</span> pipe_fd, <span class="keyword">int</span> new_fd)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建sendmsg可用的数据结构体msg，并初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建msg中的iovec结构体iov，并初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;iov, <span class="number">0</span>, <span class="keyword">sizeof</span>(iov));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//iovec必须要赋值</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    iov.iov_base = buf;</span><br><span class="line">    iov.iov_len = <span class="built_in">strlen</span>(buf);</span><br><span class="line"></span><br><span class="line">    msg.msg_iov = &amp;iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//因为cmsg中有个柔性数组，所以只能申请堆空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> *<span class="title">cmsg</span> =</span> (struct cmsghdr*)<span class="built_in">calloc</span>(<span class="number">1</span>, len);</span><br><span class="line">    cmsg-&gt;cmsg_len = len;</span><br><span class="line">    cmsg-&gt;cmsg_level = SOL_SOCKET;</span><br><span class="line">    cmsg-&gt;cmsg_type = SCM_RIGHTS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//柔性数组的数据用CMSG_DATA()接收，要进行类型转换</span></span><br><span class="line">    *(<span class="keyword">int</span>*)CMSG_DATA(cmsg) = new_fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//msg的附属数据结构体指向cmsg</span></span><br><span class="line">    msg.msg_control = cmsg;</span><br><span class="line">    msg.msg_controllen = len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用pipe_fd向子进程发送msg</span></span><br><span class="line">    <span class="comment">//用ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags)可以发送文件描述符</span></span><br><span class="line">    sendmsg(pipe_fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="transfilec文件传输函数"><a class="markdownIt-Anchor" href="#transfilec文件传输函数"></a> TransFile.c：文件传输函数</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收一次SIGPIPE信号，防止信号中断程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigfunc</span><span class="params">(<span class="keyword">int</span> signum)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGPIPE is coimg&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TransFile</span><span class="params">(<span class="keyword">int</span> client_fd)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    signal(SIGPIPE, sigfunc);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;1.pdf&quot;</span>, O_RDONLY);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;open&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前文件的状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">fileInfo</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;fileInfo, <span class="number">0</span>, <span class="keyword">sizeof</span>(fileInfo));</span><br><span class="line">    ret = fstat(fd, &amp;fileInfo);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;fstat&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建传输数据结构体</span></span><br><span class="line">    <span class="keyword">train_t</span> train;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;train, <span class="number">0</span>, <span class="keyword">sizeof</span>(train));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送文件名</span></span><br><span class="line">    train.data_len = <span class="built_in">strlen</span>(<span class="string">&quot;1.pdf&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(train.data_buf, <span class="string">&quot;1.pdf&quot;</span>);</span><br><span class="line">    ret = send(client_fd, &amp;train, <span class="number">4</span> + train.data_len, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;send&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;train, <span class="number">0</span>, <span class="keyword">sizeof</span>(train));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送文件大小</span></span><br><span class="line">    train.data_len = <span class="keyword">sizeof</span>(fileInfo.st_size);</span><br><span class="line">    <span class="built_in">memcpy</span>(train.data_buf, &amp;fileInfo.st_size, <span class="keyword">sizeof</span>(<span class="keyword">off_t</span>));</span><br><span class="line">    send(client_fd, &amp;train, <span class="number">4</span> + train.data_len, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fileSize = %ld\n&quot;</span>, fileInfo.st_size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//----------------------------------零拷贝修改区----------------------------------//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;train, <span class="number">0</span>, <span class="keyword">sizeof</span>(train));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环文件发送数据</span></span><br><span class="line">        train.data_len = read(fd, train.data_buf, <span class="keyword">sizeof</span>(train.data_buf));</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == train.data_len)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送错误则退出发送</span></span><br><span class="line">        ret = send(client_fd, &amp;train, train.data_len + <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">        ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;TransFile_send&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//发送数据为0时退出循环</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == train.data_len)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//----------------------------------零拷贝修改区----------------------------------//</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="tcpinitc创建主进程的tcp监听套接字"><a class="markdownIt-Anchor" href="#tcpinitc创建主进程的tcp监听套接字"></a> TcpInit.c：创建主进程的TCP监听套接字</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TcpInit</span><span class="params">(<span class="keyword">char</span> *ip, <span class="keyword">char</span>*port, <span class="keyword">int</span> *socket_fd)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="comment">/*分别设置协议、IP地址和端口号*/</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line">    addr.sin_port = htons(atoi(port));</span><br><span class="line"></span><br><span class="line">    *socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(*socket_fd, <span class="number">-1</span>, <span class="string">&quot;socket&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置地址可重用</span></span><br><span class="line">    <span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">    ret = setsockopt(*socket_fd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置缓冲区大小</span></span><br><span class="line">    <span class="keyword">int</span> buf = <span class="number">65536</span>;</span><br><span class="line">    ret = setsockopt(*socket_fd, SOL_SOCKET, SO_SNDBUF, &amp;buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绑定ip地址和端口号</span></span><br><span class="line">    ret = bind(*socket_fd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;bind&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听描述符，最大连接数设置为10</span></span><br><span class="line">    ret = listen(*socket_fd, <span class="number">10</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;ret&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="epolladdfdc将文件描述符添加进epoll"><a class="markdownIt-Anchor" href="#epolladdfdc将文件描述符添加进epoll"></a> EpollAddFd.c：将文件描述符添加进epoll</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EpollAddFd</span><span class="params">(<span class="keyword">int</span> epoll_fd, <span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;events, <span class="number">0</span>, <span class="keyword">sizeof</span>(events));</span><br><span class="line">    events.events = EPOLLIN;</span><br><span class="line">    events.data.fd = fd;</span><br><span class="line">    <span class="comment">//将fd添加进epoll</span></span><br><span class="line">    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;events);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="客户端设计"><a class="markdownIt-Anchor" href="#客户端设计"></a> 客户端设计</h1>
<h2 id="程序设计-2"><a class="markdownIt-Anchor" href="#程序设计-2"></a> 程序设计</h2>
<h3 id="clientc客户端主程序"><a class="markdownIt-Anchor" href="#clientc客户端主程序"></a> client.c：客户端主程序</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ARGS_CHECK(argc, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存服务器端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套接字文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(socket_fd, <span class="number">-1</span>, <span class="string">&quot;socket&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置接收缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> recv_buf = <span class="number">65536</span>;</span><br><span class="line">    ret = setsockopt(socket_fd, SOL_SOCKET, SO_RCVBUF, &amp;recv_buf, <span class="keyword">sizeof</span>(recv_buf));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    ret = connect(socket_fd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;connect&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> data_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">off_t</span> file_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.先接收文件名长度</span></span><br><span class="line">    ret = recv(socket_fd, &amp;data_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;recv_name_len&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.根据文件名长度接收文件名</span></span><br><span class="line">    ret = recv(socket_fd, buf, data_len, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;recv_name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.接收文件大小</span></span><br><span class="line">    ret = recv(socket_fd, &amp;data_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">    ret = recv(socket_fd, &amp;file_len, data_len, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.根据文件名打开文件</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(buf, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line">    ERROR_CHECK(fd, <span class="number">-1</span>, <span class="string">&quot;open&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------------------------零拷贝修改区----------------------------------//</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置接收文件的大小</span></span><br><span class="line">    <span class="keyword">off_t</span> file_len_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计次数打印进度条</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//!!!!!!!!!!!!!!!!!!!!!!!!清空缓冲区!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.接收文件长度</span></span><br><span class="line">        recv(socket_fd, &amp;data_len, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == data_len)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.接收文件数据</span></span><br><span class="line">        ret = RecvFile(socket_fd, buf, data_len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.统计现有文件大小，打印进度条</span></span><br><span class="line">        file_len_num += ret;</span><br><span class="line">        cnt = PrintProgressRate(file_len, file_len_num, cnt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.写入文件</span></span><br><span class="line">        write(fd, buf, data_len);</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------------------------零拷贝修改区----------------------------------//</span></span><br><span class="line"></span><br><span class="line">    close(socket_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="recvfilec封装一个接收指定大小数据的函数"><a class="markdownIt-Anchor" href="#recvfilec封装一个接收指定大小数据的函数"></a> RecvFile.c：封装一个接收指定大小数据的函数</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RecvFile</span><span class="params">(<span class="keyword">int</span> socket_fd, <span class="keyword">void</span> *buf, <span class="keyword">int</span> data_len)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> get_file_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(get_file_len &lt; data_len)&#123;</span><br><span class="line">        <span class="comment">//动态接收数据，等到接收数据达到想要接受的长度时退出</span></span><br><span class="line">        ret = recv(socket_fd, (<span class="keyword">char</span> *)buf + get_file_len, data_len - get_file_len, <span class="number">0</span>);</span><br><span class="line">        get_file_len += ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> get_file_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="printprogressratec打印进度条程序"><a class="markdownIt-Anchor" href="#printprogressratec打印进度条程序"></a> PrintProgressRate.c：打印进度条程序</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PrintProgressRate</span><span class="params">(<span class="keyword">off_t</span> final_num, <span class="keyword">off_t</span> now_num, <span class="keyword">int</span> cnt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> all = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">2</span>] = <span class="string">&quot;%&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(final_num == now_num)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; all; ++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;█&quot;</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;100.00%s\n&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">100</span> == ++cnt)&#123;</span><br><span class="line">        <span class="keyword">double</span> bar = (<span class="keyword">double</span>)now_num / final_num * <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> space_num = all - (<span class="keyword">int</span>)bar / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; all - space_num; ++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;█&quot;</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; space_num - <span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5.2lf%s\r&quot;</span>, bar, str);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="遇到的问题"><a class="markdownIt-Anchor" href="#遇到的问题"></a> 遇到的问题</h1>
<ol>
<li>发送文件名和文件数据粘在一块。
<ul>
<li>原因：TCP粘包问题，多次发送的数据被一次接收，数据之间没有分界线，所有数据都粘在一起。</li>
<li>解决方法：人为去设计一个结构体，规定数据与数据之间的分界线(私有协议)。</li>
</ul>
</li>
<li>客户端接收文件时，接收到的文件和服务器上的文件大小内容不一样，但是传输过程没有问题。
<ul>
<li>原因：循环接收时没有清空接收缓冲区，导致错误接收。</li>
<li>解决办法：清空接收缓冲区。</li>
</ul>
</li>
<li>客户端报栈损坏、段错误。
<ul>
<li>原因：由于发送速度不匹配，造成客户端接收数据时读取数据时不一定时正确的顺序。读取认为规定的结构体时发生错误的读取，读取到错误的数据长度，导致客户端访问到了不能访问的内存空间因此程序崩溃。</li>
<li>解决方案：①设置recv的标志位为MSG_WAITALL；②封装自己的recv函数规定接收数据大小；③写一个ERROR_CHECK()宏检测，检测到错误即使返回。</li>
</ul>
</li>
<li>客户端主动退出，服务器崩溃。
<ul>
<li>原因：服务器子程序发送失败时，用了一个ERROR_CHECK()宏检测，导致子进程异常退出，父进程与子进程间通信的文件描述符成为一个无效的文件描述符，子进程会循环发送SIGPIPE信号。</li>
<li>解决办法：传输文件处写一个signal函数捕捉SIGPIPE信号。子进程传输失败时不予理会，当作服务完成，正常向后执行（<strong>不能因为客户端的问题引起服务器崩溃</strong>）。</li>
</ul>
</li>
</ol>
<h1 id="后续可以做的改进"><a class="markdownIt-Anchor" href="#后续可以做的改进"></a> 后续可以做的改进</h1>
<ol>
<li>
<p>零拷贝传输：先前传输文件时循环调用send系统调用，发生用户态到内核态再由内核态到用户态的拷贝，使用零拷贝技术，减少内核态和用户台之间的拷贝次数，从而加快服务器传输速率。</p>
<p>客户端使用零拷贝技术接收（修改client.c的修改区使用mmap）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">beg</span>, <span class="title">end</span>;</span></span><br><span class="line">   <span class="built_in">memset</span>(&amp;beg, <span class="number">0</span>, <span class="keyword">sizeof</span>(beg));</span><br><span class="line">   <span class="built_in">memset</span>(&amp;end, <span class="number">0</span>, <span class="keyword">sizeof</span>(end));</span><br><span class="line">   </span><br><span class="line">   gettimeofday(&amp;beg, <span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line">   ftruncate(fd, file_len);</span><br><span class="line">   <span class="comment">//用mmap进行地址映射</span></span><br><span class="line">   <span class="keyword">char</span> *<span class="built_in">map</span> = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, file_len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">   ERROR_CHECK(<span class="built_in">map</span>, (<span class="keyword">char</span> *)<span class="number">-1</span>, <span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   recv(socket_fd, <span class="built_in">map</span>, file_len, MSG_WAITALL);</span><br><span class="line">   </span><br><span class="line">   munmap(<span class="built_in">map</span>, file_len);</span><br><span class="line">   </span><br><span class="line">   gettimeofday(&amp;end, <span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line"><span class="comment">//可以统计传输效率</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;total time = %lf\n&quot;</span>, (end.tv_sec - beg.tv_sec) + ((end.tv_usec - beg.tv_usec) / <span class="number">1000.0</span>) / <span class="number">1000.0</span>);</span><br></pre></td></tr></table></figure>
<p>服务器的三种零拷贝技术（修该TransFile.c的修改区）：</p>
<ul>
<li>
<p>mmap文件映射：传输240M文件0.9s左右</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.用mmap进行地址映射</span></span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">map</span> = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, fileInfo.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>); </span><br><span class="line">ERROR_CHECK(<span class="built_in">map</span>, (<span class="keyword">void</span> *)<span class="number">-1</span>, <span class="string">&quot;mmap&quot;</span>); </span><br><span class="line"><span class="comment">//发送整个map </span></span><br><span class="line">send(client_fd, <span class="built_in">map</span>, fileInfo.st_size, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//解映射</span></span><br><span class="line">munmap(<span class="built_in">map</span>, fileInfo.st_size);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>sendfile函数：传输240M文件0.7s左右</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ssize_t sendfile(int out_fd, int fd, off_t *offset, size_t count)</span></span><br><span class="line"><span class="comment">成功返回发送的字节数，失败返回-1</span></span><br><span class="line"><span class="comment">参数1：往哪写入数据</span></span><br><span class="line"><span class="comment">参数2：从哪读取数据</span></span><br><span class="line"><span class="comment">参数3：文件偏移量</span></span><br><span class="line"><span class="comment">参数4：传输数据的长度</span></span><br><span class="line"><span class="comment">sendfile只能用于发送端发送数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//2.用sendfile发送文件</span></span><br><span class="line">ret = sendfile(client_fd, fd, <span class="number">0</span>, fileInfo.st_size);</span><br><span class="line">ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;sendfile&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>splice函数：传输240M文件，发送大小设置128时需要2.2s左右，发送大小设置为65536时需要0.7s左右</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需要打开一个宏开关：#define _GNU_SOURCE</span></span><br><span class="line"><span class="comment">需要一根管道，用于发送和接收数据</span></span><br><span class="line"><span class="comment">ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags)</span></span><br><span class="line"><span class="comment">成功返回发送的字节数，失败返回-1</span></span><br><span class="line"><span class="comment">参数1：从哪取数据</span></span><br><span class="line"><span class="comment">参数2：偏移量</span></span><br><span class="line"><span class="comment">参数3：往哪写数据</span></span><br><span class="line"><span class="comment">参数4：偏移量</span></span><br><span class="line"><span class="comment">参数5：单次写入数据长度（最多65536）---&gt;可以通过这个的大小控制传输速度</span></span><br><span class="line"><span class="comment">参数6：标识位，一般填0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//3.用户splice传输文件，要利用一根管道，用文件描述符往里写，客户端通信文件描述符从里面取</span></span><br><span class="line"><span class="keyword">long</span> send_size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fds[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">pipe(fds);</span><br><span class="line"><span class="keyword">while</span>(send_size &lt; fileInfo.st_size)&#123;</span><br><span class="line">    ret = splice(fd, <span class="number">0</span>, fds[<span class="number">1</span>], <span class="number">0</span>, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">    ret = splice(fds[<span class="number">0</span>], <span class="number">0</span>, client_fd, <span class="number">0</span>, ret, <span class="number">0</span>);</span><br><span class="line">    ERROR_CHECK(ret, <span class="number">-1</span>, <span class="string">&quot;splice&quot;</span>);</span><br><span class="line">    send_size += ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>四种发送文件对比：</p>
<ul>
<li>文件速度：sendfile &gt; mmap &gt; send，splice可以自行控制速度。</li>
<li>限制：
<ol>
<li>sendfile和mmap有文件大小限制，最大可以传输2G的大文件。</li>
<li>零拷贝接口的可移植性不是很好。</li>
<li>数据传输的瓶颈始终在于<strong>网络状态</strong>。</li>
</ol>
</li>
</ul>
</li>
<li>
<p>进程池的退出。</p>
<ul>
<li>
<p>暴力退出：父进程收到退出信号后，依次杀死子进程。</p>
<p>服务器main.c添加一个全局变量out标识符，一个信号捕捉函数和一个信号处理函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局out标识位</span></span><br><span class="line"><span class="keyword">short</span> out = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main_sigfunc</span><span class="params">(<span class="keyword">int</span> signum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">10</span> == signum)&#123;</span><br><span class="line">        out = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号捕捉函数添加在创建子进程后面，以防子进程继承主函数的信号捕捉函数</span></span><br><span class="line">signal(<span class="number">10</span>, main_sigfunc);</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴力退出子进程，加在主函数while(1)中</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> == out)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process_num; ++i)&#123;</span><br><span class="line">        kill(pInfo[i].pid, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main out\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器ChildFunc.c添加一个信号捕捉函数和处理函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">child_sigfunc</span><span class="params">(<span class="keyword">int</span> signum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">10</span> == signum)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child out\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号捕捉函数</span></span><br><span class="line">signal(<span class="number">10</span>, child_sigfunc);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>温柔退出：父进程收到退出信号后，给子进程发送退出标记，如果子进程正在忙碌，忙完后自行退出。</p>
</li>
</ul>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/10/Makefile%E5%AD%A6%E4%B9%A0/" rel="prev" title="Makefile学习">
      <i class="fa fa-chevron-left"></i> Makefile学习
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/07/13/%E7%AE%A1%E9%81%93/" rel="next" title="进程间通信方式(1)-管道">
      进程间通信方式(1)-管道 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%B1%A0%E6%B5%81%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text"> 进程池流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%8C%E6%97%B6%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%BE%97%E6%9C%8D%E5%8A%A1%E6%9C%AC%E6%96%87%E4%BE%8B%E5%AD%90%E4%B8%BA%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6"><span class="nav-number">1.1.</span> <span class="nav-text"> 目的：实现多个客户端同时访问服务器获得服务(本文例子为下载文件)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A5%BD%E5%A4%841-%E9%99%8D%E4%BD%8E%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%972-%E6%8F%90%E9%AB%98%E5%93%8D%E5%BA%94%E9%80%9F%E5%BA%A63-%E6%8F%90%E9%AB%98%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8F%AF%E7%AE%A1%E7%90%86%E6%80%A7"><span class="nav-number">1.2.</span> <span class="nav-text"> 好处：1. 降低资源消耗；2. 提高响应速度；3. 提高进程的可管理性。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.</span> <span class="nav-text"> 主要工作流程：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E6%B5%81%E7%A8%8B"><span class="nav-number">1.4.</span> <span class="nav-text"> 客户端从服务器下载文件流程：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.</span> <span class="nav-text"> 服务器设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.1.</span> <span class="nav-text"> 数据结构设计：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.2.</span> <span class="nav-text"> 程序设计：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mainc%E4%B8%BB%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.2.1.</span> <span class="nav-text"> main.c：主程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#createprocessc%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.2.2.</span> <span class="nav-text"> CreateProcess.c：创建子进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#childfuncc%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%87%BD%E6%95%B0%E7%94%A8%E4%BA%8E%E5%86%99%E5%AF%B9%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="nav-number">2.2.3.</span> <span class="nav-text"> ChildFunc.c：子进程函数，用于写对客户端的服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#recvfdc%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%8E%A5%E6%94%B6%E4%B8%BB%E8%BF%9B%E7%A8%8B%E5%8F%91%E9%80%81%E7%9A%84%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">2.2.4.</span> <span class="nav-text"> RecvFd.c：子进程接收主进程发送的与客户端通信的文件描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sendfdc%E4%B8%BB%E8%BF%9B%E7%A8%8B%E5%8F%91%E9%80%81%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%BB%99%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.2.5.</span> <span class="nav-text"> SendFd.c：主进程发送与客户端通信的文件描述符给子进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#transfilec%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.6.</span> <span class="nav-text"> TransFile.c：文件传输函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcpinitc%E5%88%9B%E5%BB%BA%E4%B8%BB%E8%BF%9B%E7%A8%8B%E7%9A%84tcp%E7%9B%91%E5%90%AC%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="nav-number">2.2.7.</span> <span class="nav-text"> TcpInit.c：创建主进程的TCP监听套接字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epolladdfdc%E5%B0%86%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B7%BB%E5%8A%A0%E8%BF%9Bepoll"><span class="nav-number">2.2.8.</span> <span class="nav-text"> EpollAddFd.c：将文件描述符添加进epoll</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BE%E8%AE%A1"><span class="nav-number">3.</span> <span class="nav-text"> 客户端设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-2"><span class="nav-number">3.1.</span> <span class="nav-text"> 程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#clientc%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%BB%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.1.1.</span> <span class="nav-text"> client.c：客户端主程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#recvfilec%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E6%8E%A5%E6%94%B6%E6%8C%87%E5%AE%9A%E5%A4%A7%E5%B0%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.2.</span> <span class="nav-text"> RecvFile.c：封装一个接收指定大小数据的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#printprogressratec%E6%89%93%E5%8D%B0%E8%BF%9B%E5%BA%A6%E6%9D%A1%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.1.3.</span> <span class="nav-text"> PrintProgressRate.c：打印进度条程序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text"> 遇到的问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8E%E7%BB%AD%E5%8F%AF%E4%BB%A5%E5%81%9A%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="nav-number">5.</span> <span class="nav-text"> 后续可以做的改进</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Alebiaji</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alebiaji</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
